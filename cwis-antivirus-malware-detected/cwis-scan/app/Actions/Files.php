<?php

namespace App\Actions;
use App\Library\CwisApi;
use App\Library\CwisDirsCreator;
use App\State;

class Files extends BaseAction
{
    public function __invoke($params): ?array {

      $action = isset($params['subaction']) ? $params['subaction'] : false;
      $fn     = isset($params['fn'])     ? base64_decode($params['fn']) : false;
      $data   = isset($params['data'])   ? base64_decode($params['data']) : false;
      // No remote call for api calls flag -- don't ask original if call from dashboard..
      $nor    = isset($params['nor']);
      
      if(!$action) {
        return [ 'success' => false, 'error' => 'missing_action' ];
      }

      if(($action == 'write' || $action == 'file_write') && !$data) {
        return [ 'success' => false, 'error' => 'missing_params' ];
      }

      $ret = [ 'success' => true, 'data' => '' ];
      $fnc = State::scanPath() . DIRECTORY_SEPARATOR . $fn;

      switch($action) {

        case 'file_chmod':

          $files = isset($params['files']) ? $params['files'] : false;
          $octal = isset($params['octal']) ? intval($params['octal']) : false;

          if(!$files || !count($files) || !intval($octal) || intval($octal) > 777) {
            return [ 'success' => false, 'error' => 'missing_params' ];
          }
          $ret['data'] = [];

          foreach($files as $index => $fnc) {
            $fn = State::scanPath() . DIRECTORY_SEPARATOR . $fnc;
            if(is_file($fn)) {
              chmod($fn, octdec($octal));
              $ret['data'][] = 'Modified ' . $fn . ' to 0' . $octal;
            }
          }

        break;

        case 'file_read':
        case 'read':

          if(is_dir($fnc)) {
              return [ 'success' => false, 'error' => 'directory_cant_be_view' ];
          }

          if(!is_file($fnc)) {
            return [ 'success' => false, 'error' => 'missing_file' ];
          }

          $mime = mime_content_type($fnc);

          if($mime) {
            $mime = explode('/', $mime);
            if($mime && isset($mime[0]) && $mime[0] != 'text') {
              return [ 'success' => false, 'error' => 'non_text', 'mime' => implode('/', $mime) ];
            }
          }

          if(filesize($fnc) > 1024 * 1024 * 2) {
            return [ 'success' => false, 'error' => 'too_big', 'size' => filesize($fnc) ];
          }

          if(!$nor) {
            $ret['remote'] = CwisApi::fetch_single(substr($fn,1));
          }

          $lines = $this->getLines($fn);

          $ret['lines'] = $lines;
          $ret['data'] = base64_encode(file_get_contents($fnc));

        break;
        case 'file_write':
        case 'write':

          $ret['file'] = $fnc;
          $ret['len'] = strlen($data);
          file_put_contents($fnc, $data);

        break;
      }

      return $ret;

    }

    private function getLines($file)
    {
        if (!defined('CWIS_SCAN_PATH')) {
            define('CWIS_SCAN_PATH', substr(ABSPATH, 0, -1));
        }

        $scan_path = normalize_path(CWIS_SCAN_PATH);
        $dirsCreator = new CwisDirsCreator();
        $dirsCreator->setFilePathHash($scan_path);
        $filepath = $dirsCreator->getResultsFilePath('results');
        $serialized_data = file_get_contents_safe($filepath);
        $result = $serialized_data ? @unserialize($serialized_data) : [];

        foreach ($result as $key => $rule) {
            if (is_array($rule)) {
                foreach ($rule as $vuln) {
                    if (is_array($vuln) && isset($vuln['name'])) {
                        $fn = substr($vuln['name'], 1);
                        $lines = isset($vuln['lines']) ? $vuln['lines'] : [];

                        if ($file === $fn) {
                            if (isset($lines['line'])) {
                                return [$lines['line']];
                            } else {
                                return array_values(array_unique(array_column($lines, 'line')));
                            }
                        }
                    }
                }
            }
        }

        return [];
    }

}
