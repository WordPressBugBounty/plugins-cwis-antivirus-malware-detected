<?php

namespace App\Library;

use App\State;

class CwisThreatChecks
{
    /** @var CwisResults $results */
    public $results;

    use Definitions;

    //
    // The special regular expression characters are:
    // . \ + * ? [ ^ ] $ ( ) { } = ! < > | : -
    //
    // http://php.net/manual/en/function.preg-quote.php
    //
    // Critical files extensions and entries
    var $critical_entries = array(
        '<\?php|<[\?\%]=|#!/bin|#!/usr|php://|\$GLOBALS|\$_(COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)',
        'apache_|array_|assert|base64_decode|call_user_func|chgrp|chr|chown|copy|create_function|escape|eval|exec',
        'file|fputs|fsockopen|fwrite|get_|gzinflate|gzuncompress|md5|msg_|move|mysql|ob_|pg_|popen|reg_replace',
        'sqliteCreateFunction|sem_|shm_|shmop_|stream_|strrev|str_rot13|system|urldecode',
    );
    var $critical_files = array('cgi', 'o', 'pl', 'py', 'sh', 'so',
        'php', 'php3', 'php4', 'php5', 'php7', 'pht', 'phtm', 'phtml', 'shtml',
        'htaccess', 'infected', 'susp', 'suspected'); // used in "Server malware" report
    //
    //  Virus files types and entries
    var $virus_files = array('js', 'htm', 'html', 'suspicious');
    var $virus_entries = array(
        '<\s*(applet|embed|frame|marquee|object|script)',
        'eval\s*\(|fromCharCode|getCookie|setCookie|setInterval|setTimeout',
        '\$\(this\)\.|document\.|location\.|navigator\.|window\.'
    );
    //
    // Phishing files and entries
    var $phishing_files = array('js', 'htm', 'html', 'php', 'suspected');
    var $phishing_entries = array(
        '<\s*(body|form|html|iframe|title)',
        'account|bank|cvv|detail|login|online|pass|secur|servlet'
    );
    //
    // Public used vars
    var $code_fragment, $file_m_pos, $file_sig_id, $priority;
    //
    // Protected and internal used vars
    var $file_contents, $file_ext, $file_index, $file_name, $file_stat, $lines;
    //
    // CMS/plugins vulnerabilities list (total 15 so far)
    var $vuln_list = array(
        array(
            'name'	 => 'RCE : J15-J25 : https://docs.joomla.org/Security_hotfixes_for_Joomla_EOL_versions',
            'match'	 => array(
                'libraries/joomla/session/session.php' => array(
                    '!STRPOS' => '&& filter_var($_SERVER[\'HTTP_X_FORWARDED_FOR',
                ),
            )
        ),
        array(
            'cms'	 => 'Joomla! v1.5',
            'name'	 => 'AFU : J15 : https://docs.joomla.org/Security_hotfixes_for_Joomla_EOL_versions',
            'match'	 => array(
                'administrator/components/com_media/helpers/media.php'	 => array(
                    '!STRPOS' => '$format == \'\' || $format == false ||',
                ),
                'joomla/filesystem/file.php'							 => array(
                    '!STRPOS' => '$file = rtrim($file, \'.\');',
                ),
            )
        ),
        array(
            'name'	 => 'AFU : FCKEDITOR : http://www.exploit-db.com/exploits/17644/ & /exploit/249',
            'match'	 => array(
                'editor/filemanager/upload/test.html'						 => null,
                'editor/filemanager/browser/default/connectors/php/'		 => null,
                'editor/filemanager/connectors/uploadtest.html'				 => null,
                'editor/filemanager/browser/default/connectors/test.html'	 => null,
            ),
        ),
        array(
            'name'	 => 'AFU : REVSLIDER : http://www.exploit-db.com/exploits/35385/',
            'match'	 => array(
                'inc_php/image_view.class.php'				 => array(
                    '!STRPOS' => 'showImageByID',
                ),
                '/inc_php/framework/image_view.class.php'	 => array(
                    '!STRPOS' => 'showImageByID',
                ),
            )
        ),
        array(
            'name'	 => 'AFU : elFinder',
            'match'	 => array(
                'elfinder/php/connector.php' => array(
                    '!STRPOS' => 'array(\'image\', \'text/plain\')'
                )
            )
        ),
        array(
            'cms'	 => 'Drupal',
            'name'	 => 'SQLI : DRUPAL : CVE-2014-3704',
            'match'	 => array(
                'includes/database/database.inc' => array(
                    'STRPOS' => 'foreach ($data as $i => $value)',
                ),
            )
        ),
        array(
            'name'	 => 'AFD : MINIFY : CVE-2013-6619',
            'match'	 => array(
                'engine/classes/min/index.php' => array(
                    '!STRPOS' => 'tr_replace(chr(0)',
                ),
            )
        ),
        array(
            // http://www.acunetix.com/blog/wordpress-security/timthumb-vulnerability-wordpress-plugins-themes/
            'name'	 => 'RCE : TIMTHUMB : CVE-2011-4106,CVE-2014-4663',
            'match'	 => array(
                'thumb.php'	 => array(
                    'STRPOS' => 'code.google.com/p/timthumb',
                    'STRPOS' => 'stristr($url_info[\'host\'], $site)'
                ),
                'cache.php'	 => array(
                    'STRPOS' => 'code.google.com/p/timthumb',
                    'STRPOS' => 'stristr($url_info[\'host\'], $site)'
                ),
            )
        ),
        array(
            'cms'	 => 'Joomla',
            'name'	 => 'RCE : RSFORM : rsform.php, LINE 1605',
            'match'	 => array(
                'components/com_rsform/helpers/rsform.php' => array(
                    'STRPOS' => 'eval($form->ScriptDisplay);',
                ),
            )
        ),
        array(
            'name'	 => 'CODE INJECTION : FANCYBOX',
            'match'	 => array(
                'fancybox-for-wordpress/fancybox.php' => array(
                    'STRPOS' => '\'reset\' == $_REQUEST[\'action\'] )',
                ),
            )
        ),
        array(
            'name'	 => 'AFU : Cherry Plugin',
            'match'	 => array(
                'cherry-plugin/admin/import-export/upload.php' => array(
                    '!STRPOS' => 'verify nonce',
                ),
            )
        ),
        array(
            'name'	 => 'AFU : TINYMCE : http://www.exploit-db.com/exploits/9296/',
            'match'	 => array(
                'tiny_mce/plugins/tinybrowser/tinybrowser.php' => null,
            )
        ),
        array(
            'name'	 => 'AFU : UPLOADIFY : CVE: 2012-1153',
            'match'	 => array(
                '/uploadify.php' => array(
                    'STRPOS' => 'move_uploaded_file($tempFile,$targetFile',
                ),
            )
        ),
        array(
            'name'	 => 'AFU : adsmanager_afu',
            'match'	 => array(
                'com_adsmanager/controller.php' => array(
                    'STRPOS' => 'move_uploaded_file($file[\'tmp_name\'], $tempPath.\'/\'.basename($file[',
                ),
            )
        ),
        array(
            'name'	 => 'AFU : https://www.pluginvulnerabilities.com/2016/05/31/aribitrary-file-upload-vulnerability-in-wp-mobile-detector/',
            'match'	 => array(
                'plugins/wp-mobile-detector/resize.php' => array(
                    'STRPOS' => 'file_put_contents($path, file_get_contents($_REQUEST[\'src\']));',
                ),
            )
        )
    );

    /**
     * Use this method as a class constructor.
     */
    function construct(&$app)
    {
        // Gets the properties of the app
        $vars = array_keys(get_object_vars($app));

        // Pointers to the properties
        foreach ($vars as $prop) {
            $this->{$prop} = & $app->{$prop};
        }

        // Reset values
        $this->file_m_pos = 0;
        $this->file_sig_id = null;
    }

    /**
     * Checks if CMS detected, additionally may check the version too.
     * @param array $cms_list
     * @param string $name
     * @param string $version
     * @return bool
     */
    function checkCMSVersion($cms_list = array(), $name = '', $version = '')
    {
        if (!$name || !is_array($cms_list)) {
            return false;
        }

        foreach ($cms_list as $cms_detected) {
            if (!is_array($cms_detected)) {
                $cms_detected = array($cms_detected);
            }

            foreach ($cms_detected as $cms_name_version) {
                if (false !== stripos($cms_name_version, $name)) {
                    if (!$version || false !== stripos($cms_name_version, $version)) {
                        return true;
                    }
                }
            }
        }

        return false;
    }

    /**
     * Checks signatures in the loop.
     * @param string contents
     * @param array $sig_names
     * @param bool $is_preg
     * @return bool
     */
    function checkSignaturesMatches($contents = '', $sig_names = array(), $is_preg = true)
    {
        $this->lines = [];
        foreach ($sig_names as $sig_name) {

            // Check for regExp/string signatures matches
            $result = $this->signatures->checkContents($contents, $sig_name, $is_preg);
            if (false !== $result) {
                // Match offset, checksum and priority
                $this->file_m_pos = $result['offset'];
                $this->file_sig_id = $result['sigid'];
                $this->priority = $result['index'] + 1;

                // Debug info
                $this->logger->scanlogMessage('File: "' . $this->utilities->filenameShrink($this->file_name) .
                    //'" with sigId "' . $this->file_sig_id .
                    '" matched ' . $sig_name . '[' . $result['index'] . '] with ' .
                    ($is_preg ? 'PREG "#(' . $result['regexp'] . ')#smiS"' : 'STRING "' . $result['regexp'] . '"') .
                    ' in ' . $this->file_m_pos);

                // Get fragment of malicious code
                $this->code_fragment = $this->getFragment($this->file_contents, $this->file_m_pos);
                $marker_line_no = substr_count(substr($this->file_contents, 0, $this->file_m_pos), "\n") + 1;
                $this->lines[] = ['line' => $marker_line_no, 'offset' => $this->file_m_pos,
                    'fragment' => $this->code_fragment];
                return true;
            }
        }

        return false;
    }

    /**
     * Checks for known CMS and plugins vulnerabilities.
     * @return bool
     */
    function checkVulnerability()
    {
        // Lowercased and slash-normalised file name
        $file_name_normalised = str_replace(DIRECTORY_SEPARATOR, '/', strtolower($this->file_name));

        // Get detected CMS list
        $this->results->select('DetectedCMS');
        $cms_list = $this->results->get();

        // Cycle through CMS list
        foreach ($this->vuln_list as $vuln_id => $vuln_data) {
            if (!is_array($vuln_data) || !isset($vuln_data['match'])) {
                continue;
            }

            $vuln_cms = isset($vuln_data['cms']) ? $vuln_data['cms'] : null;
            $vuln_name = isset($vuln_data['name']) ? $vuln_data['name'] : $vuln_id;
            $vuln_match = isset($vuln_data['match']) ? $vuln_data['match'] : array();

            // Check CMS version first (correct format: "CMS v1.2")
            if ($vuln_cms && !$this->checkCMSVersion($cms_list, preg_replace('/\s+v/i', "\t", $vuln_cms))) {
                continue;
            }

            // Process match parameters
            foreach ($vuln_match as $path => $expressions) {
                if (!$path || false === stripos($file_name_normalised, $path)) {
                    continue;
                }

                // Validate expression
                if (!$expressions || !is_array($expressions)) {
                    $this->code_fragment = $vuln_name;
                    return true;
                }

                // Process expressions in [AND] mode
                $expressions_matched = $expressions_total = 0;
                foreach ($expressions as $type => $expression) {
                    if (false !== strpos($type, 'STRPOS')) {
                        $strpos_match = (bool) (false !== strpos($this->file_contents, $expression));
                        if (($strpos_match && $type === 'STRPOS') ||
                            (!$strpos_match && $type === '!STRPOS')) {
                            $expressions_matched++;
                        }
                    } elseif (false !== strpos($type, 'PREG')) {
                        $preg_match = (bool) (false !== preg_match('#' . $expression . '#smi', $this->file_contents));
                        if (($preg_match && $type === 'PREG') ||
                            (!$preg_match && $type === '!PREG')) {
                            $expressions_matched++;
                        }
                    }
                    $expressions_total++;
                }

                // Add scan result
                if ($expressions_total > 0 && $expressions_matched === $expressions_total) {
                    $this->code_fragment = $vuln_name;
                    return true;
                }
            }
        }
    }

    /**
     * Filters non-printable (control and invisible) characters.
     * @param string $str
     * @return string
     */
    function filterNonPrintableChars($str)
    {
        if (State::phpVersion() >= 50304) {
            return preg_replace('/[^\pL\pN\pP\pS\pZ]/u', '~', $str);
        } else {
            return preg_replace('/[\x00-\x1F\x7F-\xFF]/', '~', $str);
        }
    }

    /**
     * Returns an array of standardized result entry data compatible with CwisResults.
     * @return array
     */
    function getResultEntryData()
    {
        return array(
            'id'		 => $this->file_index,
            'name'		 => $this->file_name,
            'fragment'	 => $this->code_fragment,
            'lines'	     => $this->lines,
            'sig'		 => $this->file_sig_id,
            'stat'		 => $this->file_stat
        );
    }

    /**
     * Extracts the fragement of a string.
     * @param string $content
     * @param integer $marker_pos
     * @return string
     */
    function getFragment($content = '', $marker_pos = 0)
    {
        $content_length = strlen($content);
        if ($marker_pos < 0) {
            $marker_pos = 0;
        }

        // Define left and right substr positions around the marker
        $left_pos = max(0, $marker_pos - round(State::cnf('CWIS_MAX_PREVIEW_LENGTH') / 2)); // divide by two
        $right_pos = min($marker_pos + State::cnf('CWIS_MAX_PREVIEW_LENGTH'), $content_length);

        // Define marker's line number
        $marker_line_no = substr_count(substr($content, 0, $marker_pos), "\n") + 1;

        // Build output, filter non-printable characters
        $output = '[_BEGIN_]' . $marker_line_no . "[_END_]  "
            . ($left_pos > 0 ? '...' : '')
            . $this->filterNonPrintableChars(
                substr($content, $left_pos, $marker_pos - $left_pos)
            )
            . '[_MARKER_]'
            . $this->filterNonPrintableChars(
                substr($content, $marker_pos, $right_pos - $marker_pos)
            )
            . ($right_pos < $content_length ? '...' : '');

        // Encoded output
        //$output_encoded = htmlspecialchars($this->utilities->unwrapObfuscated($output), ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');
        $output_encoded = htmlspecialchars($output, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');
        return $output_encoded;
    }

    /**
     * Checks if an URL is in ignore list (known).
     * @param string $url_match
     * @return bool
     */
    function isKnownUrl($url_match = '')
    {
        if (empty($url_match)) {
            return false;
        }

        // Convert matched URL to support the protocol relative links
        $this->logger->debugMessage('isKnownUrl(' . $url_match . ')');
        $url = str_replace('//', '://', stripslashes($url_match));

        // Select and pass URL ignore list
        $this->results->select('UrlIgnoreList');
        $url_ignore_list = $this->results->get();
        foreach ($url_ignore_list as $url_to_ignore) {
            $url_pos = stripos($url, $url_to_ignore);
            if (false === $url_pos) {
                continue;
            }

            // Check the char next to URL (hacker domains, phishing etc)
            $url_char = substr($url, $url_pos + strlen($url_to_ignore), 1);
            if (!$url_char || preg_match("#[^a-z0-9\.-]#si", $url_char)) {
                return true;
            }
        }

        return false;
    }

    // --- THREATS CHECK METHODS ---

    /**
     * Checks for known AdWare signatures.
     * @return bool
     */
    function checkAdware()
    {
        // Define signature name and check it
        $sig_names = array('g_AdwareSig', 'gX_AdwareSig');
        if ($this->checkSignaturesMatches($this->file_contents, $sig_names)) {
            return true;
        }

        // Articles AdWare check
        if (false !== stripos($this->file_name, 'article_index')) {
            $this->code_fragment = $this->getFragment($this->file_contents);
            return true;
        }

        return false;
    }

    /**
     * Checks for known JS viruses.
     * @return bool
     */
    function checkCriticalJS()
    {
        // Skip non-critical files (by extension)?
        $is_non_critial_file = ($this->config->scan_level <= 1);

        // Don't analyse PDO records
        if ($is_non_critial_file && !$this->utilities->filenameIsPdoRecord($this->file_name)) {
            foreach ($this->virus_files as $file_ext) {
                if (strpos($this->file_name, $file_ext) !== false) {
                    $is_non_critial_file = false;
                    break;
                }
            }
        }

        // Check for virus entries
        $cwisPreg = new \App\Library\CwisPreg();
        if ($is_non_critial_file && $cwisPreg->match($this->virus_entries, $this->file_contents)) {
            $is_non_critial_file = false;
        }

        // If not critical - skip it (Basic Check)
        if ($is_non_critial_file && $this->config->scan_level <= 1) {
            $this->logger->scanlogMessage('CriticalJS: "' . $this->utilities->filenameShrink($this->file_name) .
                '" skipped, not critical.');

            return false;
        }

        // Define signatures names and check them
        $sig_names = array('g_JSVirSig', 'gX_JSVirSig');
        return $this->checkSignaturesMatches($this->file_contents, $sig_names);
    }

    /**
     * Checks for critical PHP files and PHP entries.
     * @return bool
     */
    function checkCriticalPHP()
    {
        // Skip non-critical files (by extension)?
        $is_non_critial_file = ($this->config->scan_level <= 1);

        // Don't analyse PDO records
        if ($is_non_critial_file && !$this->utilities->filenameIsPdoRecord($this->file_name)) {
            foreach ($this->critical_files as $file_ext) {
                if (false !== stripos($this->file_name, $file_ext)) {
                    $is_non_critial_file = false;
                    break;
                }
            }
        }

        // Check for critical entries
        $cwisPreg = new \App\Library\CwisPreg();
        if ($is_non_critial_file && $cwisPreg->match($this->critical_entries, $this->file_contents)) {
            $is_non_critial_file = false;
        }

        // If not critical - skip it (Basic Check)
        if ($is_non_critial_file && $this->config->scan_level <= 1) {
            $this->logger->scanlogMessage('CriticalPHP: "' . $this->utilities->filenameShrink($this->file_name) .
                '" skipped, not critical.');

            return false;
        }

        // Define signatures names and check them
        $sig_names = array('g_FlexDBShe', 'gX_FlexDBShe', 'gXX_FlexDBShe');
        /* if ($this->config->scan_level >= 2) {
          $sig_names[] = 'gXX_FlexDBShe'; //deprecated
          } */
        if ($this->checkSignaturesMatches($this->file_contents, $sig_names)) {
            return true;
        }

        // Check non-regexp signatures
        if ($this->config->scan_level >= 2) {

            // Check file content in lowercase
            $file_contents_lo = strtolower($this->file_contents);

            // Check primary signature names (g_DBShe and gXXX_DBShe)
            if ($this->checkSignaturesMatches($file_contents_lo, array('g_DBShe'), $is_preg = false)) {
                return true;
            }

            // Check if professional scan level or executable file
            if ($this->config->scan_level >= 3 || /** #!/usr/local/bin/php -n <?php */
                false !== strpos($file_contents_lo, '<') ||
                0 === strpos($file_contents_lo, '#!/')) {

                // Check secondary signature names (hacker nick names)
                if ($this->checkSignaturesMatches($file_contents_lo, array('gX_DBShe'), $is_preg = false)) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Check for custom coded critical PHP files.
     * @return bool
     */
    function checkCriticalPHPCustom()
    {
        $filesize = isset($this->file_stat['size']) ? $this->file_stat['size'] : 0;

        // Check for GIF89-signature in php-file
        if ((0 === strpos($this->file_contents, 'GIF89')) && (false !== stripos($this->file_name, '.php'))) {
            $this->file_m_pos = 0;

            $this->logger->scanlogMessage('CriticalPHP: "' . $this->utilities->filenameShrink($this->file_name) .
                '" matched GIF89-signature in php-file.');

            return true;
        }

        // detect uploaders / droppers
        if ($this->config->scan_level >= 3) {
            $matches = null;
            if (
                ($filesize < 1024) &&
                (false !== strpos($this->file_name, '.ph')) &&
                (
                    (($this->file_m_pos = strpos($this->file_contents, 'multipart/form-data')) > 0) ||
                    (($this->file_m_pos = strpos($this->file_contents, '$_FILE[') > 0)) ||
                    (($this->file_m_pos = strpos($this->file_contents, 'move_uploaded_file')) > 0) ||
                    (preg_match('|\bcopy\s*\(|smi', $this->file_contents, $matches, PREG_OFFSET_CAPTURE))
                )
            ) {
                if ($matches != null) {
                    $this->file_m_pos = $this->signatures->getMatchOffset($matches);
                }

                $this->logger->scanlogMessage('CriticalPHP: "' . $this->utilities->filenameShrink($this->file_name) .
                    '" matched as uploader / dropper.');

                return true;
            }
        }

        return false;
    }

    /**
     * Checks empty links (used in black-hat SEO).
     * @return bool
     */
    function checkEmptyLinks()
    {
        // Scan all files or files containing "index."
        if ($this->config->scan_all_files || stripos($this->file_name, 'index.')) {
            $matches = array();

            // Check empty links
            if (((State::cnf('CWIS_RMASK_FULL') & CWIS_RMASK_SPAMLINKS) == CWIS_RMASK_SPAMLINKS) &&
                (preg_match_all('#<a[^>]+href([^>]+?)>(.*?)</a>#smi', $this->file_contents, $matches, PREG_OFFSET_CAPTURE))) {

                // External link URLs
                $ext_links_sources = array();
                $ext_links_total = 0;

                $matches_count = count($matches[0]);
                for ($ki = 0; $ki < $matches_count; $ki++) {
                    $match_result = $matches[0][$ki][0];
                    $match_link_href = $matches[1][$ki][0];
                    $match_link_text = $matches[2][$ki][0];

                    // Check if http-link and is not the site URL
                    $this->file_m_pos = strpos($match_link_href, '//');
                    if (false === $this->file_m_pos || false !== stripos($match_link_href, $this->config->site_url)) {
                        continue;
                    }

                    // Match a valid link with an empty anchor (skip image with a src attribute and PHP-code snippets)
                    if (trim(strip_tags($match_link_text)) === '' &&
                        !preg_match('#(?:<img[^>]+src([^>]+?)>|<\?php(.+)\?>)#si', $match_link_text) &&
                        preg_match('#\=\s*[\'\"]?((f|ht)tps?:)?//[^/]+#si', $match_link_href) &&
                        !$this->isKnownUrl($match_link_href)) {

                        // Link source
                        $ext_links_sources[] = substr($match_result, 0, State::cnf('CWIS_MAX_PREVIEW_LENGTH'));

                        // Limit max links count
                        if ($ext_links_total++ >= State::cnf('CWIS_MAX_EXTERNAL_LINKS')) {
                            break;
                        }
                    }
                }

                // One-time record
                if ($ext_links_total > 0) {
                    $this->code_fragment = $ext_links_sources;
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Performs a heuristic check.
     * @return bool
     */
    function checkHeuristic()
    {

        // File time most likely changed by touch
        if ($this->file_stat['ctime'] < $this->file_stat['mtime']) {
            $this->code_fragment = State::cnf('CWIS_SUSP_FILE_MTIME'); //file type
            return true;
        }

        // Check permissions readability
        $perm = $this->file_stat['mode']/* fileperms($this->file_name) */ & 0777;
        if (($perm & 0400 != 0400) || // not readable by owner
            ($perm == 0000) ||
            ($perm == 0404) ||
            ($perm == 0505)) {
            $this->code_fragment = State::cnf('CWIS_SUSP_FILE_PERM'); //file type
            return true;
        }

        // Check for php-files in uploads
        if ((strpos($this->file_name, '.ph')) && (
                strpos($this->file_name, '/images/stories/') ||
                //strpos($this->file_name, '/img/') ||
                //strpos($this->file_name, '/images/') ||
                //strpos($this->file_name, '/uploads/') ||
                strpos($this->file_name, '/wp-content/upload/')
            )
        ) {
            $this->code_fragment = State::cnf('CWIS_SUSP_PHP_IN_UPLOAD'); //file type
            return true;
        }

        /*
         * @TODO new scan method
         * 	string begins from digit
         * 	count of digits in substr > 50%
         * 	pattern <lowercase letters or numbers><2+ uppercase>
         * 	pattern <digits><1-3 symbols><digit>
         * 	pattern <symbol><3+ digits><symbol>
         * 	pattern <symbol><4+ digits>
         * 	has no vowels in a row
         * 	has uppercase, lowercase and digits
         * 	has three vowels in a row
         * 	two digits are not next to each other
         */

        return false;
    }

    /**
     * Checks if hidden linux's file (AKA dot-file).
     * @return bool
     */
    function checkHiddenFiles()
    {
        $basename = basename($this->file_name);
        return (bool) (0 === strpos($basename, '.'));
    }

    /**
     * Checks .htaccess file for known vulnerabilities.
     * @return bool
     */
    function checkHtaccess()
    {
        $this->lines = [];

        // Check for suspicious signatures
        if (false !== ($this->file_m_pos = stripos($this->file_contents, 'index.php?name=$1')) ||
            false !== ($this->file_m_pos = stripos($this->file_contents, 'index.php?m=1')) ||
            false !== ($this->file_m_pos = stripos($this->file_contents, 'auto_prepend_file')) ||
            false !== ($this->file_m_pos = stripos($this->file_contents, 'auto_append_file')) ||
            false !== ($this->file_m_pos = stripos($this->file_contents, '^(%2d|-)[^=]+$'))
        ) {
            $this->code_fragment = $this->getFragment($this->file_contents, $this->file_m_pos);
            $marker_line_no = substr_count(substr($this->file_contents, 0, $this->file_m_pos), "\n") + 1;
            $this->lines[] = ['line' => $marker_line_no, 'offset' => $this->file_m_pos,
                'fragment' => $this->code_fragment];
            return true;
        }

        // Check for external redirects
        $matches = array();
        if (
            preg_match_all("#[^\#\B]RewriteRule\s+[\'\"]?[^'\"\s]+[\'\"]?\s+"
                . "[\'\"]?https?:\/\/(?:www\.)?([^\'\"\s]+)[\'\"]?\s+"
                . "\[[\,\=\w]*R(?:=\d+)?[\,\=\w]*\]#smi", $this->file_contents, $matches, PREG_OFFSET_CAPTURE)
        ) {
            // Self host name (without www.)
            $self_host = $this->config->http_host;
            if (substr($self_host, 0, 4) === "www.") {
                $self_host = substr($self_host, 4);
            }

            // Analyse hosts in rewrite rules
            $matches_count = count($matches[0]);
            for ($ki = 0; $ki < $matches_count; $ki++) {
                $match_link_host = $matches[1][$ki][0];
                $match_offset = $matches[0][$ki][1] + 1;

                $this->logger->scanlogMessage('Htaccess: "' . $this->utilities->filenameShrink($this->file_name) .
                    '" matched redirect fragment in ' . $match_offset);

                // Compare hosts and get code fragment on difference
                if (0 !== strpos($match_link_host, '%{HTTP_HOST}') &&
                    0 !== strpos($match_link_host, $self_host)) {

                    // Suspicious code fragment position
                    $this->file_m_pos = $match_offset;
                    $this->code_fragment = $this->getFragment($this->file_contents, $this->file_m_pos);
                    $marker_line_no = substr_count(substr($this->file_contents, 0, $this->file_m_pos), "\n") + 1;
                    $this->lines[] = ['line' => $marker_line_no, 'offset' => $this->file_m_pos,
                        'fragment' => $this->code_fragment];
                    return true;
                }
            }
        }

        // Check for usage of unknown types for PHP extensions
        // http://php.net/manual/en/security.hiding.php
        if (
            preg_match_all("#(Action|AddHandler|AddType|ForceType|SetHandler)\s+"
                . "(application\/x-httpd(?:-php)?(?:-cgi)?|php[3-7]?-script|phtml-script)\s+"
                . "([!\#-;=?-\[\]_a-z~]+)\s*$#smi", $this->file_contents, $matches, PREG_OFFSET_CAPTURE)
        ) {
            // Analyse matches in rewrite rules
            $matches_count = count($matches[0]);
            for ($ki = 0; $ki < $matches_count; $ki++) {
                $this->file_m_pos = $matches[0][$ki][1];

                $this->logger->scanlogMessage('Htaccess: "' . $this->utilities->filenameShrink($this->file_name) .
                    '" matched usage of unknown types in ' . $this->file_m_pos);

                // Malicious code fragment
                $this->code_fragment = $this->getFragment($this->file_contents, $this->file_m_pos);
                return true;
            }
        }

        return false;
    }

    /**
     * Checks iframes for injections.
     * @return bool
     */
    function checkIframeInjections()
    {
        $this->lines = [];

        // Scan all files or files containing "index."
        if ($this->config->scan_all_files || stripos($this->file_name, 'index.')) {
            $matches = array();

            // Check iframes for injections
            if (preg_match_all('#<iframe[^>]+?src([^>]+?)>#smi', $this->file_contents, $matches, PREG_OFFSET_CAPTURE)) {

                $matches_count = count($matches[0]);
                for ($ki = 0; $ki < $matches_count; $ki++) {
                    $match_link_href = $matches[1][$ki][0];
                    $match_link_offset = $matches[1][$ki][1];

                    // Check if http-link ("Recommended" scan level only)
                    if ($this->config->scan_level === 2 && false === strpos($match_link_href, '//')) {
                        continue;
                    }

                    // Filter known URLs
                    if (!$this->isKnownUrl($match_link_href)) {

                        // Suspicious code fragment position
                        $this->file_m_pos = $match_link_offset;
                        $this->code_fragment = $this->getFragment($this->file_contents, $this->file_m_pos);
                        $marker_line_no = substr_count(substr($this->file_contents, 0, $match_link_offset), "\n") + 1;
                        $this->lines[] = ['line' => $marker_line_no, 'offset' => $match_link_offset,
                            'fragment' => $this->code_fragment];

                        return true;
                    }
                }
            }

            return false;
        }
    }

    /**
     * Checks for potentially malicious code.
     * @return bool
     */
    function checkMaliciousCode()
    {
        // Define signatures names and check them
        $sig_names = array('g_SusDB', 'gX_SusDB', 'gXX_SusDB');
        return $this->checkSignaturesMatches($this->file_contents, $sig_names);
    }

    /**
     * Checks contents for phishing signatures.
     * @return bool
     */
    function checkPhishing()
    {
        // Skip non-critical files (by extension)?
        $is_non_critial_file = ($this->config->scan_level <= 1);

        // Don't analyse PDO records
        if ($is_non_critial_file && !$this->utilities->filenameIsPdoRecord($this->file_name)) {
            foreach ($this->phishing_files as $file_ext) {
                if (false !== strpos($this->file_name, $file_ext)) {
                    $is_non_critial_file = false;
                    break;
                }
            }
        }

        // Check for virus entries
        $cwisPreg = new \App\Library\CwisPreg();
        if ($is_non_critial_file && $cwisPreg->match($this->phishing_entries, $this->file_contents)) {
            $is_non_critial_file = false;
        }

        // If not critical - skip it (Basic Check)
        if ($is_non_critial_file && $this->config->scan_level <= 1) {
            $this->logger->scanlogMessage('Phishing: "' . $this->utilities->filenameShrink($this->file_name) .
                '" skipped, not critical.');

            return false;
        }

        // Define signature name and check it
        $sig_names = array('g_PhishSig');
        return $this->checkSignaturesMatches($this->file_contents, $sig_names);
    }

    /**
     * Checks for PHP code inside any type of file.
     * @return bool
     */
    function checkPHPCode()
    {
        $matches = array();
        $this->lines = [];

        // Exit if has extension of the php-file
        if (0 === strpos($this->file_ext, 'ph')) {
            return false;
        }

        // Basename in lowercase
        $basename = strtolower(basename($this->file_name));
        if ($basename === 'readme.md' || $basename === 'readme.txt') {
            return false;
        }

        // Detect PHP-tag with comments, valid examples:
        // "<?php if(1)", "<?php #()", "<?php //", "<?php /*"
        if (
            preg_match("~<\?php[\w\s\#\/\*\(]{3,}~smi", $this->file_contents, $matches, PREG_OFFSET_CAPTURE) ||
            // Check javascript source for keyword "PHP"
            preg_match("~(<script[^>]*(language\s*=\s*)?)('|\"|)php('|\"|)([^>]*>)~smi", $this->file_contents, $matches,
                PREG_OFFSET_CAPTURE)
        ) {
            $this->file_m_pos = $matches[0][1];
            $this->code_fragment = $this->getFragment($this->file_contents, $this->file_m_pos);
            $marker_line_no = substr_count(substr($this->file_contents, 0, $this->file_m_pos), "\n") + 1;
            $this->lines[] = ['line' => $marker_line_no, 'offset' => $this->file_m_pos,
                'fragment' => $this->code_fragment];

            return true;
        }

        return false;
    }

    /**
     * Check for private addresses (used in private networks only).
     * @return bool
     */
    function checkPrivateIP()
    {
        $matches = array();
        $this->lines = [];

        if (preg_match_all("#(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})#", $this->file_contents, $matches, PREG_OFFSET_CAPTURE)) {

            // Match addresses in IPv4 format
            for ($n = 0; $n < count($matches[0]); $n++) {
                $part1 = (int) $matches[1][$n][0];
                $part2 = (int) $matches[2][$n][0];
                $part3 = (int) $matches[3][$n][0];
                $part4 = (int) $matches[4][$n][0];

                // Simple IP range validation 0.0.0.0 - 192.255.255.255
                if ($part1 > 255 || $part2 > 255 || $part3 > 255 || $part4 > 255) {
                    continue;
                }

                // Check IANA-reserved private IPv4 network ranges:
                // 10.0.0.0 - 10.255.255.255        Private network, 24-bit block (/8 prefix, 1 x A)
                // 127.0.0.0 - 127.255.255.255      localhost (loopback)
                // 169.254.0.0 - 169.254.255.255    Link-local address also refered to as Automatic Private IP Addressing
                // 172.16.0.0 - 172.31.255.255      Private network, 20-bit block (/12 prefix, 16 x B)
                // 192.0.0.0 - 192.0.0.255          TEST-NET-1, documentation and examples
                // 192.0.2.0 - 192.0.2.255          TEST-NET-1, documentation and examples
                // 192.88.99.0 - 192.88.99.255      IPv6 to IPv4 relay
                // 192.168.0.0 - 192.168.255.255    Private network, 16-bit block (/16 prefix, 256 x C)
                // 198.51.100.0 - 198.51.100.255    TEST-NET-2, documentation and examples
                // 203.0.113.0 - 203.0.113.255      TEST-NET-3, documentation and examples
                // 224.0.0.0 - 224.255.255.255      IP multicast (former Class D network)
                // 240.0.0.0 - 240.255.255.255      Reserved (former Class E network)
                // 254.169.0.0 - 254.169.255.255    Automatic Private IP Addressing (APIPA)
                // https://en.wikipedia.org/wiki/IPv4
                if (
                    ($part1 === 10) ||
                    ($part1 === 127) ||
                    ($part1 === 169 && $part2 === 254) ||
                    ($part1 === 172 && ($part2 >= 16 && $part2 <= 31)) ||
                    ($part1 === 192 && $part2 === 0 && ($part3 === 0 || $part3 === 2)) ||
                    ($part1 === 192 && $part2 === 88 && $part3 === 99) ||
                    ($part1 === 192 && $part2 === 168) ||
                    ($part1 === 198 && $part2 === 51 && $part3 === 100) ||
                    ($part1 === 203 && $part2 === 0 && $part3 === 113) ||
                    ($part1 === 224) ||
                    ($part1 === 240) ||
                    ($part1 === 254 && $part2 === 169)
                ) {
                    // Suspicious IP is a private address or loopback
                    $this->file_m_pos = $matches[0][$n][1];
                    $this->code_fragment = $this->getFragment($this->file_contents, $this->file_m_pos);
                    $marker_line_no = substr_count(substr($this->file_contents, 0, $this->file_m_pos), "\n") + 1;
                    $this->lines[] = ['line' => $marker_line_no, 'offset' => $this->file_m_pos,
                        'fragment' => $this->code_fragment];
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Checks for backdoor/web shells signatures.
     * @return bool
     */
    function checkWebShells()
    {
        // Define signatures names and check them
        $sig_names = array('g_WebShells', 'gX_WebShells');
        return $this->checkSignaturesMatches($this->file_contents, $sig_names);
    }

}
