<?php

namespace App\Library;

use App\State;
use App\Library\CwisApi;

class CwisWhitelist
{

    // Whitelist size
    var $list_size = 0;
    //
    // Whitelist filenames (default is the 1st file in the list)
    var $list_files = array('.userlist.db', '.quicklist.db', '.whitelist.db');

    /**
     * Use this method as a class constructor.
     * @param mixed $config
     */
    function construct($config = null)
    {
        // Instantiate the logger class
        $this->logger = new \App\Library\CwisLogger();

        // Use configuration options
        if (gettype($config) === 'object') {
            $this->logger->setScanPath($config->getScanPath());
        }
    }

    // --- PRIVATE METHODS ---

    /**
     * Optimized binary search, returns a hash position in the string or FALSE if not found.
     * @param string $str
     * @param string $hash
     * @return bool
     */
    function binarySearchHash($str = '', $hash = '', $optimized = false)
    {
        $hash_size = strlen($hash);
        $str_length = strlen($str);

        if ($hash_size < 20 || $str_length < 20) {
            return false;
        }

        // Check if hash exists (4 iterations: 16*20 = 320 is optimal)
        if ($optimized && $str_length < 320) {
            $strpos = strpos($str, $hash);
            if (false !== $strpos && $strpos % 20 === 0) {
                return $strpos;
            }
        }

        // Check big data...
        $first = 0;
        $last = floor($str_length / 20);

        // If seeked part isn't empty, than first < last
        while ($first < $last) {
            $mid = $first + (($last - $first) >> 1);
            $b = substr($str, $mid * 20, 20);
            if (strcmp($hash, $b) <= 0) {
                $last = $mid;
            } else {
                $first = $mid + 1;
            }
        }

        // Var $last contains hash index, convert to hash_pos
        return $last * 20;
    }

    /**
     * Searches for hashes in chunk contents.
     * @param array $hashes
     * @param integer $chunk_id
     * @param string $chunk_contents
     * @return array|null
     */
    function searchChunkContents(& $hashes, $chunk_id = 0, $chunk_contents = '')
    {
        // Check for the last hash reached
        if (false === ($hash = current($hashes))) {
            return null;
        }

        $result = array();

        do {
            // Validate binary SHA1 hash
            if (false === $this->validateSha1Hash($hash)) {
                continue;
            }

            // Get the hash ID and search in chunk contents
            $hash_id = ($hash ? ord($hash[0]) : 0) + 1;

            // Compare the IDs first
            if ($chunk_id != $hash_id) {
                continue;
            }

            // Search for hash in chunk contents, use optimized algorithm, save result if item found
            $hash_pos = $this->binarySearchHash($chunk_contents, $hash, $optimized = true);
            if (false !== $hash_pos && $hash === substr($chunk_contents, $hash_pos, strlen($hash))) {
                $result[] = $hash;
            }
        } while ($chunk_id >= $hash_id && $hash = next($hashes));

        return $result;
    }

    /**
     * Validates binary SHA1 hash (automatically packs hash in hex number format).
     * @param string $hash
     * @return bool
     */
    function validateSha1Hash(& $hash)
    {
        // Pack the 40-character hexadecimal number
        $hash_length = strlen($hash);
        if ($hash_length === 40) {
            $hash = pack("H*", $hash);
            $hash_length = strlen($hash);
        }

        // Validate binary SHA1 hash
        if ($hash_length !== 20) {
            return false;
        }

        return true;
    }

    // --- Hash Management ---

    /**
     * Inserts a new hash into chunk (optionally removes an exists hash).
     * @param array $chunks
     * @param string $hash
     * @return bool
     */
    function manageHashChunk(& $chunks, $hash = '', $remove = false)
    {
        // Validate binary SHA1 hash
        if (false === $this->validateSha1Hash($hash)) {
            return false;
        }

        // Get the hash ID
        $hash_id = +($hash ? ord($hash[0]) : 0);
        $chunk_contents = $chunks[$hash_id];

        // Search in chunk contents
        $hash_pos = $this->binarySearchHash($chunk_contents, $hash);
        if (false === $hash_pos) {
            $hash_is_found = false;
        } else {
            // Check if hash has already been added
            $hash_is_found = (bool) ($hash === substr($chunk_contents, $hash_pos, 20));
        }

        // Remove hash
        if ($remove) {
            if ($hash_is_found) {
                // Remove an already exists hash
                $chunks[$hash_id] = substr_replace($chunk_contents, '', $hash_pos, 20);
                return true;
            }

            return false;
        }

        // Insert hash
        if (!$hash_is_found) {
            // Hash is not found, put it into last position
            $chunks[$hash_id] = substr_replace($chunk_contents, $hash, $hash_pos, 0);
            return true;
        }

        return false;
    }

    /**
     * Merges passed chunks arrays to one.
     * @param string $filename
     * @return array
     */
    function mergeArrayChunks()
    {
        $chunks = array_fill(0, 256, '');

        // Process function's arguments
        $numargs = func_num_args();
        if ($numargs > 0) {
            $chunks_list = func_get_args();
            for ($n = 0; $n < $numargs; $n++) {
                if (empty($chunks_list[$n])) {
                    $chunks_list[$n] = array_fill(0, 256, '');
                }
            }

            // Process array of 256 chunks
            for ($i = 0; $i < 256; $i++) {
                $primary_chunk = str_split($chunks_list[0][$i], 20);
                for ($n = 1; $n < $numargs; $n++) {
                    $secondary_chunk = str_split($chunks_list[$n][$i], 20);
                    $merged_chunks = array_merge($primary_chunk, $secondary_chunk);
                    $unique_chunks = !empty($merged_chunks) ? array_keys(array_flip($merged_chunks)) : array();
                    $chunks[$i] = implode('', $unique_chunks);
                }
            }
        }

        return $chunks;
    }

    /**
     * Reads all 256 chunks as an array from binary file.
     * @param string $filename
     * @return array
     */
    function readArrayChunks($filename = '')
    {
        $chunks = array_fill(0, 256, '');

        if (!file_exists($filename)) {
            return $chunks;
        }

        $fp = @fopen($filename, 'rb');
        if (false === $fp) {
            return $chunks;
        }

        // Unpack file header
        $contents = fread($fp, 1024);
        if (strlen($contents) === 1024) {
            $header = unpack('V256', $contents);
        } else {
            return $chunks;
        }

        // Validate header content
        foreach ($header as $chunk_id => $chunk_size) {
            if ($chunk_size % 20 !== 0) {
                return $chunks;
            }
        }

        // There's 256 chunks (1 <= chunk_id <= 256)
        foreach ($header as $chunk_id => $chunk_size) {
            if ($chunk_size < 20) {
                continue;
            }

            // Load the chunk contents to array
            $chunks[$chunk_id - 1] = fread($fp, $chunk_size);
        }
        fclose($fp);

        return $chunks;
    }

    /**
     * Saves an array of 256 chunks into binary file.
     * @param string $filename
     * @param array $chunks
     */
    function saveArrayChunks($filename = '', $chunks = array())
    {
        // Pack file header
        $header = array();
        foreach ($chunks as $chunk_id => $chunk_value) {
            $header[$chunk_id] = pack('V', strlen($chunk_value));
        }

        if (!($fp = fopen($filename, 'wb'))) {
            return false;
        }

        // Write header and chunk contents
        fwrite($fp, implode($header));
        foreach ($chunks as $chunk_contents) {
            fwrite($fp, $chunk_contents);
        }

        fclose($fp);

        return true;
    }

    /**
     * Sorts hashes of the passed array with chunk contents.
     * @param array $chunks
     * @return array
     */
    function sortArrayChunksHashes($chunks = array())
    {
        // Process array of 256 chunks
        for ($i = 0; $i < 256; $i++) {
            if (!isset($chunks[$i])) {
                $chunks[$i] = '';
            } else {
                $hashes = str_split($chunks[$i], 20);
                sort($hashes); // binary sorting
                $chunks[$i] = implode('', $hashes);
            }
        }

        return $chunks;
    }

    /**
     * Counts all hashes in the passed array of chunks.
     * @param array $chunks
     * @return array
     */
    function countArrayChunksHashes($chunks = array())
    {
        $count = 0;
        foreach ($chunks as $chunk_value) {
            $count += floor(strlen($chunk_value) / 20);
        }

        return $count;
    }

    // --- PUBLIC METHODS ---

    function checkHashes($hashes = array())
    {
        if (empty($hashes) || !is_array($hashes)) {
            return array();
        }

        // Try populate whitelist file
        CwisApi::whitelist_fetch(State::listsPath() . DIRECTORY_SEPARATOR . end($this->list_files));

        $this->logger->debugMessage('$whitelist->check()');

        // Important!
        sort($hashes);

        // Filter empty CRC hashes, prepare 1st hash
        $hashes_filtered = array_filter($hashes, 'strlen');

        // Process whitelists
        $results = array();
        $this->list_size = 0;
        foreach ($this->list_files as $whitelist_filepath) {

            // Trying to read a whitelist's file
            $file = State::makePath([State::listsPath(), $whitelist_filepath]);

            $fp = is_file($file) ? fopen($file, 'rb') : false;
            if (false === $fp) {
                $this->logger->debugMessage('Cannot load whitelist file "' . $whitelist_filepath . '"!');
                continue;
            }

            // Get a whitelist size
            $whitelist_size = max(0, filesize($file) - 1024) / 20;
            $this->list_size += ceil($whitelist_size);

            // Unpack header
            $contents = fread($fp, 1024);
            if (strlen($contents) === 1024) {
                $header = unpack('V256', $contents);
            } else {
                $this->logger->debugMessage('Empty or invalid whitelist file "' . $whitelist_filepath . '"!');
                continue;
            }

            // There's 256 chunks (1 <= chunk_id <= 256)
            foreach ($header as $chunk_id => $chunk_size) {
                if ($chunk_size < 20) {
                    continue;
                }

                // Load the chunk contents
                $chunk_contents = fread($fp, $chunk_size);

                // Search for hash in chunk contents
                $result = $this->searchChunkContents($hashes_filtered, $chunk_id, $chunk_contents);

                // Exit loop if last hash reached
                if (null === $result) {
                    break;
                }

                // Combine results
                if (!empty($result)) {
                    $results = array_merge($results, $result);
                }
            }
            fclose($fp);

            // Update initial hashes list
            $hashes_filtered = array_diff($hashes_filtered, $results);
            if (false === reset($hashes_filtered)) {
                break;
            }
        }
        $this->logger->debugMessage("Loaded " . $this->list_size . " known file hashes");

        return $results;
    }

    /**
     * Return the PHP source code in filename with PHP comments and whitespace removed.
     * @param string $file_name
     * @return string
     */
    function fileContentUnwrapped($file_name = '')
    {
        // Suppress PHP warnings
        return @php_strip_whitespace($file_name);
    }

    /**
     * Convert file content to UTF-8 using function "iconv".
     * @param string $file_contents
     * @param string $utf_encoding
     * @return bool
     */
    function fileContentUtf8Encoded(&$file_contents, $utf_encoding = '')
    {
        if (!$utf_encoding) {
            // Detect unicode
            $utf_encoding = detect_utf_encoding($file_contents);
        }

        // Convert to UTF-8 using iconv()
        if ($utf_encoding && functions_exists('iconv')) {
            if (($unwrapped_iconv = @iconv($utf_encoding, "UTF-8//TRANSLIT//IGNORE", $file_contents))) {

                // Get file contents after errors check
                $file_contents = $unwrapped_iconv;
                return true;
            }
        }

        return false;
    }

    /**
     * Calculates the SHA1 hash of a string.
     * @param string $str
     * @return string
     */
    function getSha1Hash($str = '')
    {
        // sha1 (PHP 4 >= 4.3.0)
        if (State::phpVersion() >= 40300) {
            // PREG uses 33% less memory and 12% faster than strtr()
            return sha1(preg_replace('/[\x00-\x20\x80-\xFF]+/', '', $str));
        }

        return null;
    }

    /**
     * Calculates the SHA1 hash of a string.
     * @staticvar array $rej
     * @param string $str
     * @return string
     */
    function getSha1Hash_old($str = '')
    {
        static $rej = array();

        // sha1_file (PHP 4 >= 4.3.0)
        if (State::phpVersion() >= 40300) {
            if (empty($rej)) {
                for ($n = 0; $n < 256; $n++) {
                    if ($n <= 32 || $n >= 128) {
                        $rej[chr($n)] = '';
                    }
                }
            }

            return sha1(strtr($str, $rej));
        }

        return null;
    }

    /**
     * Returns size of loaded whitelists.
     * @return integer
     */
    function getSize()
    {
        return $this->list_size;
    }

    function insertHash($hash = '', $offset = 0, $length = 1)
    {
        $result = 0;

        // Process a slice of the list of whitelist files
        $list_files = array_slice($this->list_files, $offset, $length);
        foreach ($list_files as $list_file) {
            $whitelist_filename = State::makePath([State::listsPath(), $list_file]);
            $chunks = $this->readArrayChunks($whitelist_filename);
            $result += $this->manageHashChunk($chunks, $hash, $remove = false);

            // Save array of chunks with sorted hashes (important)
            $this->saveArrayChunks($whitelist_filename, $this->sortArrayChunksHashes($chunks));
        }

        return $result;
    }

    function removeHash($hash = '', $offset = 0, $length = 1)
    {
        $result = 0;

        // Process a slice of the list of whitelist files
        $list_files = array_slice($this->list_files, $offset, $length);
        foreach ($list_files as $list_file) {
            $whitelist_filename = State::makePath([State::listsPath(), $list_file]);
            $chunks = $this->readArrayChunks($whitelist_filename);
            if (array_filter($chunks)) { // check if all the array items are not empty
                $result += $this->manageHashChunk($chunks, $hash, $remove = true);

                // Save array of chunks with sorted hashes (important)
                $this->saveArrayChunks($whitelist_filename, $this->sortArrayChunksHashes($chunks));
            }
        }

        return $result;
    }

}
