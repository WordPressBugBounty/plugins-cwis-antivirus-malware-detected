<?php

namespace App\Library;

use App\State;

class CwisConfig
{
    var $max_size_to_scan; // Max filesize to scan (2048K)
    var $memory_limit = '1536M'; // System memory limit override (1536M)
    var $memory_limit_default = ''; // Initial memory limit set by default
    var $max_execution_time = 30; // Max execution time of the script (30)
    var $http_host = '', $site_url = ''; // Website host and URL
    var $ext_scan = ''; // Extensions list for exclusive scan (empty by default)
    var $ext_skip = 'mp3, wav, m4a, flac, mp4, ogg, webm, mpg, ogv, m4v, asf, avi, flv, swf, css, webp, jpeg, svg, jpg, png, gif, raw, bmp, eot, ttf, woff, woff2, otf'; // Custom extensions list, for example: "eot,otf,ttf,woff"
    //
    // Email options (defaults)
    var $report_path = ''; // Report path or email address(es) to send report to
    var $send_mail = false; // Send email on scan completed? (deprecated)
    var $send_alerts = false; // Send notifications and security alerts? (PRO feature)
    var $send_reports = false; // Send scan reports via email? (PRO feature)
    //
    // Scan results filtering (since 3.2.5)
    var $filter = ''; // Text to filter (matches regular expressions)
    var $filter_exp = false; // Match regular expression?
    var $filter_inv = false; // Inverse (exclude matches)?
    //
    // Security vulnerabilities check (since 4.1.3)
    var $sec_vuln = false; // Disabled by default
    //
    // Database settings
    var $database = array(
        'type'	 => 'auto',
        'host'	 => 'localhost',
        'user'	 => '',
        'pass'	 => '',
        'name'	 => '*',
        'prefix' => ''
    );
    //
    // Important! Do not use the NULL in config defaults, quote from isset() docs:
    // "isset() will return FALSE if testing a variable that has been set to NULL"
    //
    // Overridable options
    var $scan_all_files = false; // Perform full scan (rather than just a .js, .php, .html, .htaccess)
    var $scan_database = 0; // Database scanning (null - initial, 0 - scan disabled, 1 - scan enabled)
    var $scan_delay = 0; // Delay in file scanning to reduce system load (milliseconds)
    var $scan_depth = -1; // Recursive directory-scanning depth limit ("-1" for unlimited depth)
    var $scan_level = 3; // Scan level (0/1 - for Basic Check, 2 - for Recommended and 3 - for Professional, with additional check for potentially malicious code)
    var $scan_path = ''; // Path to directory, directories and/or file(s) to scan (scan_path_default by default)
    var $scan_path_default = ''; // Default path to start scan from (may be set via constant CWIS_SCAN_PATH)
    var $scan_shuffle = true; // Randomize scan paths (0 - sequential, 1 - simultaneous scanning)
    var $scan_timeout = 0; // Scan timeout (by default 0 seconds in CLI and 2 seconds in AJAX mode)
    var $scan_type = 0; // Scan type (type 1 - full scan, type 2 - quick rescan, type 3 - full rescan)
    var $scan_modified = true; // Scan modified files using SHA1 hashes (0 - disabled)
    var $scan_via_cli = false; // Background scan via CLI (0 - disabled)
    //
    // Scheduler options
    var $scan_start = ''; // Scan start (date in format YYYY-MM-DD HH:MM)
    var $scan_end = ''; // Scan end date (date in format YYYY-MM-DD HH:MM)
    var $scan_last = ''; // Last scan date (date in format YYYY-MM-DD HH:MM)
    var $scan_frequency = ''; // Scan frequency (twice a day, daily, weekly, bi-weekly, monthly etc)
    //
    // Server options only
    var $scan_directory = ''; // Scan directory (absolute server path to user accounts or per-user Web directories, for example: /home/)
    var $scan_dir_exclude = '.cpanel,.trash,mail,ssl,tmp'; // Top-level directories to exclude (separated by commas)
    //
    // Scan levels (named "modes" in the past)
    var $scan_levels = array(
        1	 => 'basic check',
        2	 => 'recommended',
        3	 => 'professional'
    );
    //
    // Scan types
    var $scan_types = array(
        0	 => 'cache',
        1	 => 'full scan',
        2	 => 'quick rescan',
        3	 => 'full rescan'
    );

    /**
     *  Basic application configuration, should not run more than one time.
     */
    function basicConfiguration()
    {
        // Get debug mode state
        $cwis_debug_mode = (int)State::cwisDebug();

        // Error reporting
        switch ($cwis_debug_mode) {
            case 0:
                error_reporting(0);
                break;

            case 1:
                error_reporting(E_ALL ^ E_NOTICE ^ E_PARSE ^ E_WARNING);
                break;

            default:
                error_reporting(E_ALL);
        }

        $this->max_size_to_scan = State::cnf('MAX_SIZE_TO_SCAN');

        // Define website host and URL
        $this->http_host = CwisStaticHelpers::get_server_host();

        // Define site URL
        $this->site_url = 'http://' . $this->http_host . '/';

        $this->report_vars = State::cnf('CWIS_REPORT_VARS');

        // Ignore user abort
        ignore_user_abort(true);

        // Check if ini_get() is enabled
        if (State::cnf('ini_get_enabled')) {
            // Set a new memory limit (override with minimal value of 1MiB)
            if (isset($this->memory_limit) && ($memory_limit = shorthand_to_bytes($this->memory_limit)) > 1048576) {
                $this->memory_limit_default = ini_get('memory_limit');
                if (State::cnf('ini_set_enabled')) { //check if not disabled for security reasons
                    ini_set('memory_limit', $memory_limit);
                }
            }
        }

        // Check if ini_set() is enabled
        if (State::cnf('ini_set_enabled')) {
            // Option "internal_encoding" available since PHP 4 >= 4.0.6,
            // while in PHP 5.6 and later is set to "UTF-8" by default
            if (State::phpVersion() < 50600) {
                ini_set('default_charset', 'UTF-8');
                ini_set('mbstring.internal_encoding', 'UTF-8');
            }

            ini_set('realpath_cache_size', '16M');
            ini_set('realpath_cache_ttl', '1200');
            ini_set('pcre.backtrack_limit', '150000');
            ini_set('pcre.recursion_limit', '150000');

            // Enable PHP logging
            if ($cwis_debug_mode) {
                ini_set("log_errors", 1);
                ini_set("error_log", $error_log = State::makePath([State::tempPath(), "CWIS-PHP-ERROR.php"]));
                if (!is_file($error_log)) {
                    file_put_contents_safe($error_log, '<?php exit; ?>' . PHP_EOL);
                }
            }
        }

        // Check if ini_get() and ini_set() are enabled
        if (State::cnf('ini_get_enabled') && State::cnf('ini_set_enabled')) {
            if ((State::phpVersion() >= 50300 || !ini_get_bool('safe_mode')) && functions_exists('set_time_limit')) {
                set_time_limit(900000);
            } else {
                ini_set('max_execution_time', '900000');
            }

            // Get the maximum time in seconds a script is allowed to run before it is terminated by the parser.
            if (0 == ($this->max_execution_time = ini_get('max_execution_time'))) {
                $this->max_execution_time = 900000; //250hrs
            }
        }
    }

    /**
     *  Defines named constants used by application.
     */
    function defineConstants()
    {
        // Get debug mode state
        $cwis_debug_mode = (int)State::cwisDebug();

        // Check if ini_get() is enabled
        if (State::cnf('ini_get_enabled')) {

            // Create logger
            $this->logger = new CwisLogger();
            $this->logger->setScanPath($this->getScanPath());

            // Set a new memory limit
            if (isset($this->memory_limit)) {
                $memory_limit = shorthand_to_bytes($this->memory_limit);
                $memory_limit_default = shorthand_to_bytes($this->memory_limit_default);
                if ($cwis_debug_mode >= 3 && $memory_limit !== $memory_limit_default) { // extended logging
                    $this->logger->debugMessage('Memory limit changed to ' . $this->memory_limit);
                }
            }

            // Get real max_execution_time
            $max_execution_time = ini_get('max_execution_time');
            $this->logger->debugMessage('Max execution time is ' . $max_execution_time);

            // Get real memory_limit
            $memory_limit = ini_get('memory_limit');
            $this->logger->debugMessage('Memory limit is ' . $memory_limit);
        }
    }

    /**
     * Parses POSTed options.
     */
    function getPostedOptions($params)
    {
        // Is database scan enabled?
        $scan_database = isset($params['database']) ? $params['database'] : null;
        if (null !== $scan_database) {
            $this->setScanDatabase($scan_database);
        }

        // Set directory-scanning depth limit
        $scan_depth = isset($params['depth']) ? $params['depth'] : null;
        if (null !== $scan_depth) {
            $this->setScanDepth($scan_depth);
        }

        // Set scan level (default is 0 - basic check)
        $scan_level = isset($params['level']) ? $params['level'] : null;
        if (null !== $scan_level) {
            $this->setScanLevel($scan_level);
        }

        // File extensions to exclude from scanning
        $ext_skip = isset($params['extskip']) ? $params['extskip'] : null;
        if(null !== $ext_skip) {
            $this->ext_skip = $ext_skip;
        }

        // Scan modified files using SHA1 hashes
        $scan_modified = isset($params['modified']) ? $params['modified'] : null;
        if (null !== $scan_modified) {
            $this->scan_modified = (bool) $scan_modified;
        }

        // Set scan path (or use defaults if autopath is enabled)
        $scan_autopath = isset($params['autopath']) ? $params['autopath'] : 0;
        if (!$scan_autopath) {
            $scan_path = isset($params['scanpath']) ? $params['scanpath'] : '';
            $this->setScanPath($scan_path);
        } else {
            $this->setScanPath();
        }

        // Continue scan/rescan or display the JSON only
        $this->scan_type = (int) (isset($params['scantype']) ? $params['scantype'] : 0);

        // Set scan timeout (default is 5 seconds)
        $this->scan_timeout = (int) (isset($params['timeout']) ? $params['timeout'] : 5);

        /////////////////////////////////////////////
        // Report email address(es) to send report to
        $this->report_path = isset($params['email']) ? $params['email'] : '';

        // Send alerts and reports on scan completed? (PRO feature)
        $this->send_mail = (bool) (isset($params['sendmail']) ? $params['sendmail'] : 0);
        $this->send_alerts = (bool) (isset($params['sendalerts']) ? $params['sendalerts'] : 0);
        $this->send_reports = (bool) (isset($params['sendreports']) ? $params['sendreports'] : 0);

        /////////////////////////////////////////////
        // Scan results filtering (since 3.2.5)
        $this->filter = isset($params['filter']) ? $params['filter'] : '';
        $this->filter_exp = (bool) (isset($params['filterexp']) ? $params['filterexp'] : 0);
        $this->filter_inv = (bool) (isset($params['filterinv']) ? $params['filterinv'] : 0);

        /////////////////////////////////////////////
        // Security vulnerabilities check (since 4.1.3)
        $this->sec_vuln = (bool) (isset($params['secvuln']) ? $params['secvuln'] : 0);

    }

    /**
     * Converts extensions list in format "ext1,ext2,ext3.." to an array.
     * @param string $extensions
     * @return array
     */
    function parseExtList($extensions = '')
    {
        $list = array();
	if(is_array($extensions)) { return $extensions; }
        $parsed_extensions = explode(',', strtolower($extensions));
        foreach ($parsed_extensions as $parsed_extension) {
            if (($ext = trim($parsed_extension, " \n\r\t\0\x0B"))) {
                $list[] = $ext;
            }
        }

        return $list;
    }

    /**
     *  Updates scan timeout (dynamic correction).
     */
    function updateScanTimeout()
    {
        // Exit if no timeout set (eg unlimited)
        if ($this->scan_timeout <= 0) {
            return null;
        }

        // Get time taken
        $benchmark = new \App\Library\CwisBenchmark ();
        $time_needed = $benchmark->calculateTimeTaken(0);

        // Timeout correction
        if ($time_needed > 0) {

            // Dynamic timeout correction (where 4 is the count of required CDN files).
            // CDN-hosted cwis-*.php files are: app, core, scanner and signatures.
            if ($this->scan_timeout < $time_needed * 4) {
                $this->scan_timeout += $time_needed;
            } else {
                $this->scan_timeout -= $time_needed;
            }
        }

        // Validate timeout (min 1 sec and max is 10 sec)
        if ($this->scan_timeout < 1) {
            $this->scan_timeout = 1;
        } elseif (!(State::isCli() && !CWIS_IS_CGI) && !State::isCron()) {
            if ($this->scan_timeout > 10) {
                $this->scan_timeout = 10;
            }

            // When the max.exec.time is limited
            if ($this->max_execution_time < 40) {
                $this->scan_timeout = min($this->scan_timeout, $this->max_execution_time >> 2);
            }
        }
    }

    /**
     * Returns the scan database status as a string description.
     * @return string
     */
    function getScanDatabaseStr()
    {
        return $this->scan_database ?
            'enabled' : 'disabled';
    }

    /**
     * Returns the scan level as a string description.
     * @return string
     */
    function getScanLevelStr()
    {
        return isset($this->scan_levels[$this->scan_level]) ?
            $this->scan_levels[$this->scan_level] : 'unknown';
    }

    /**
     * Sets a new scan delay (time in milliseconds).
     * @param int $scan_delay
     */
    function setScanDelay($scan_delay = 0)
    {
        // Validate and update
        if ($scan_delay < 0) {
            $scan_delay = 0;
        }

        $this->scan_delay = (int) $scan_delay;
    }

    /**
     * Sets a new directory-scanning depth limit (-1 for unlimited depth).
     * @param int $scan_depth
     */
    function setScanDepth($scan_depth = -1)
    {
        // Validate and update
        if ($scan_depth < 0 || $scan_depth > 2147483647) {
            $scan_depth = -1;
        }

        $this->scan_depth = (int) $scan_depth;
    }

    /**
     * Validates states of scan_database and scan_level settings.
     */
    function validateScanSettings()
    {
        // Limit states in Free version
        if (!$this->isPremium()) {
            $this->scan_database = 0;
            //$this->scan_level = 1;
        }
    }

    /**
     * Sets database scan state (0 - disabled, 1 - enabled).
     * @param int $scan_database
     */
    function setScanDatabase($scan_database = 0)
    {
        // Validate and update
        $this->scan_database = $scan_database ? 1 : 0;
    }

    /**
     * Sets a new scan level and updates related option "scan_all_files".
     * @param int $scan_level
     */
    function setScanLevel($scan_level = 0)
    {
        // Validate and update
        if ($scan_level < 1) {
            $scan_level = 1;
        } elseif ($scan_level > 3) {
            $scan_level = 3;
        }

        // Set numeric level
        $this->scan_level = (int) $scan_level;

        // Perform full scan (rather than just a .js, .php, .html, .htaccess)
        $this->scan_all_files = ($this->scan_level >= 2);
    }

    /**
     * Sets scan timeout (2 seconds by default).
     * @param int $scan_timeout
     */
    function setScanTimeout($scan_timeout = 0)
    {
        $this->scan_timeout = (int) $scan_timeout;
    }

    /**
     * Sets a new scan type (0 - cache, 1 - full scan, 2 - quick rescan, 3 - full rescan).
     * @param int $scan_type
     */
    function setScanType($scan_type = 0)
    {
        // Validate and update
        if ($scan_type < 0) {
            $scan_type = 0;
        } elseif ($scan_type > 3) {
            $scan_type = 3;
        }

        $this->scan_type = (int) $scan_type;
    }

    /**
     * Gets current scan path (eg start point), optionally may return a relative path.
     * @param bool $relative
     * @return string
     */
    function getScanPath($relative = false)
    {
        return $relative ? str_replace(array(State::scanPath() . DIRECTORY_SEPARATOR, State::scanPath()), '',
            $this->scan_path) : $this->scan_path;
    }

    /**
     * Gets an array of unique non-empty scan paths (eg start points).
     * @return array
     */
    function getScanPaths()
    {
        $utilities = new \App\Library\CwisUtilities();
        return $utilities->splitScanPath($this->scan_path);
    }

    /**
     * Counts all scan paths in merged scan path (if multiple directories specified).
     * @return int
     */
    function countScanPaths()
    {
        return substr_count($this->scan_path, ',') + 1;
    }

    /**
     * Sets a new scan path or the list of paths (via "scanpath" option).
     * @param string $scan_path
     */
    function setScanPath($scan_path = '', $realpath = false)
    {
        if (empty($scan_path)) {
            $this->scan_path = State::scanPath();
        } else {
            $scan_path = normalize_path($scan_path);
            /*
              // Resolve to absolute (real) pathname
              $this->scan_path = ($realpath && $scan_path[0] !== DIRECTORY_SEPARATOR) ?
              realpath($scan_path) : $scan_path;
             */

            // Resolve to absolute (real) pathname
            $utilities = new \App\Library\CwisUtilities();
            $this->scan_path = $realpath ? $utilities->getRealScanPath($scan_path) : $scan_path;
        }
    }

    /**
     * Returns the scan type as a string description.
     * @return string
     */
    function getScanTypeStr()
    {
        return isset($this->scan_types[$this->scan_type]) ?
            $this->scan_types[$this->scan_type] : 'unknown';
    }

    /**
     * Verifies license type.
     * @return bool
     */
    function isPremium()
    {
        return (State::cnf('license') === 'Trial' || State::cnf('license') === 'Professional' || State::cnf('license') === 'Premium' || State::cnf('license') === 'Business');
    }
}
