<?php

namespace App\Library;

use App\State;
use App\Library\CwisPdo;

class CwisScanner
{
    /** @var CwisResults $results */
    public $results;

    use Definitions;

    //
    // Files extensions (used in quick scan)
    var $sensitive_files = array('asp', 'aspx', 'css', 'js', 'htaccess', 'htm', 'html',
        'inc', 'php', 'php3', 'php4', 'php5', 'php7', 'pht', 'phtm', 'phtml', 'shtml',
        'sql', 'tpl', 'txt'); // used in basic check (level 0/1) and in MIME types check
    var $executable_files = array('asm', 'bat', 'bin', 'c', 'cfm', 'cgi', 'csh', 'cpp',
        'deb', 'dll', 'exe', 'java', 'jsp', 'o', 'out', 'pl', 'py', 'rb', 'rpm',
        'run', 'sh', 'so', 'vmx'); // used in "Unix executables" report
    //
    // Exclusive extensions to scan
    var $exclusive_files = '';
    //
    // Doorway files extensions
    var $short_list_ext = array('php', 'php3', 'php4', 'php5', 'php7',
        'html', 'htm', 'html', 'phtml', 'shtml', 'khtml');
    //
    // Protected and internal used vars
    var $file_contents_unwrapped = null;
    //
    // Buffer volume's size (lines)
    var $fn_buffer_volume = 10000;
    //
    // Check if tokenizer is loaded
    var $tokenizer_loaded = false;

    /**
     * Use this method as a class constructor.
     */
    function construct(&$app, &$results)
    {
        // Gets the properties of the app
        $vars = array_keys(get_object_vars($app));

        // Pointers to the properties
        foreach ($vars as $prop) {
            $this->{$prop} = & $app->{$prop};
        }

        // Pass results object
        $this->results = new \App\Library\CwisResults();
        $this->results->setResults($results);

        // Instantiate the core classes
        $this->whitelist = new CwisWhitelist();
        $this->whitelist->construct($this->config);

        // Exclusive extensions to scan
        if ($this->config->ext_scan) {
            $this->exclusive_files = $this->config->parseExtList($this->config->ext_scan);
        }

        // The PHP tokenizer extension should be enabled
        $this->tokenizer_loaded = (functions_exists('extension_loaded') && extension_loaded('tokenizer'));
    }

    // --- PRIVATE METHODS ---

    /**
     * Adds check results indirectly.
     * @param string $var_name
     * @param array $entry_data
     * @param bool $unshift
     * @param int $limit
     */
    function addCheckResultsIndirect($var_name = '', $entry_data = array(), $unshift = false, $limit = 0)
    {
        // Process defined variables only
        if (!$this->results->isValidName($var_name)) {
            $response = new \App\Library\CwisResponse();
            $response->jsonError($this->results->getLastError());
        }

        // Select active results var name
        $this->results->select($var_name);

        // Check if entry name is defined
        if (!isset($entry_data['name'])) {
            $this->logger->scanLogMessage('Undefined result entry name in "' . $var_name . '": ' .
                print_r($entry_data, 1) . '.');
            return false;
        }

        // Check results limits and save the memory, e.g unset
        // 'id', 'name', 'fragment', 'sig', 'stat' and 'crc'...
        if ($limit > 0) {
            $count = $this->results->count();

            if ($count >= $limit) { // unset redundant data
                unset($entry_data['id'], $entry_data['sig']);
            }
            if ($count >= $limit * 2) { // leave only the entry name
                unset($entry_data['fragment'], $entry_data['stat'], $entry_data['lines']);
            }
            if ($count >= $limit * 5) { // empty (hide) the record
                $entry_data = array();
            }
        }

        // Check if result entry is not a PDO record
        if (isset($entry_data['name']) && !$this->utilities->filenameIsPdoRecord($entry_data['name'])) {

            // Treat entry as a file and repack file name
            $file_name = $this->utilities->filenameExpand($entry_data['name']);
            $entry_data['name'] = $this->utilities->filenameShrink($file_name);

            // Get CRC of the unwrapped content
            if ($this->file_contents_unwrapped && ($file_contents_length = strlen($this->file_contents_unwrapped)) &&
                $this->benchmark->getMemoryAvailable() > $file_contents_length * 2) {
                $entry_data['crc'] = $this->whitelist->getSha1Hash($this->file_contents_unwrapped);
            }
        }

        // Process the result entry data
        $this->results->buildEntry($entry_data);

        // Prepend or push result after duplicates check
        if ($unshift) {
            $this->results->unshift();
        } else {
            $this->results->push();
        }
    }

    /**
     * Moves the check result to the report list of whitelisted files.
     * @param string $var_name
     * @param integer $key
     * @return bool
     */
    function moveCheckResultsToWhitelisted($var_name = '', $key = 0)
    {
        // Process defined variables only
        if (!$this->results->isValidName($var_name)) {
            $response = new \App\Library\CwisResponse();
            $response->jsonError($this->results->getLastError());
        }

        // Move this check result to the whitelisted results
        $this->results->select($var_name);
        $this->results->moveTo('Whitelisted', $key);

        return true;
    }

    function getResultCount()
    {
        return count($this->results->filterByKey('name'));
    }

    //--- Files Manipulations ---

    function cachedFileStat($file_name = '')
    {
        if (!$file_name) {
            return null;
        }

        $file_stat = @stat($file_name);
        $stat = $this->parseFileStat($file_stat);

        return $stat;
    }

    // --- Check Results Methods ---

    function filterExceptionRules($exceptFlex = array())
    {
        // Convert exception rules (array_filter - PHP 4 >= 4.0.6, not supported by IonCube)
        //$unwrappedExceptFlex = array_filter($exceptFlex, array($this->utilities, 'unwrapObfuscated'));
        $unwrappedExceptFlex = array();
        foreach ($exceptFlex as $flex) {
            $unwrappedExceptFlex[] = $this->utilities->unwrapObfuscated($flex);
        }

        // Filter empty exception rules
        $filteredExceptFlex = array_filter($unwrappedExceptFlex, 'trim');

        // Return non-sparse array
        return array_values($filteredExceptFlex);
    }

    /**
     * Parses file statistics.
     * @staticvar array $filetypes
     * @param array $file_stat
     * @param bool $parse_permissions
     * @return array
     */
    function parseFileStat($file_stat = array(), $parse_permissions = false)
    {
        // Known file types list
        static $filetypes = array(
            0140000	 => 's|socket', // socket
            0120000	 => 'l|link', // symbolic link
            0100000	 => '-|file', // regular file
            0060000	 => 'b|block', // block special device
            0040000	 => 'd|dir', // directory
            0020000	 => 'c|char', // character special device
            0010000	 => 'p|fifo' // FIFO (named pipe)
        );

        // The first character of the stat's mode indicates the file type and
        // is not related to permissions.
        $filemode = isset($file_stat['mode']) ? +$file_stat['mode'] : 0;

        // Extract file type encoding bit
        $typebit = $filemode & 0170000;

        // File size in bytes
        $filesize = isset($file_stat['size']) ? +$file_stat['size'] : 0;

        // Get the type of the given file
        $filetype = isset($filetypes[$typebit]) ? substr($filetypes[$typebit], 2) : 'unknown';

        // Time of last file status change
        $filectime = isset($file_stat['ctime']) ? +$file_stat['ctime'] : 0;

        // Time of last file modification
        $filemtime = isset($file_stat['mtime']) ? +$file_stat['mtime'] : 0;

        // Optimized file stat
        $stat = array(
            'mode'	 => $filemode,
            'size'	 => $filesize,
            'type'	 => $filetype,
            'ctime'	 => $filectime,
            'mtime'	 => $filemtime,
        );

        // Parse permissions?
        if ($parse_permissions) {
            // Create Unix permissions symbolic notation (as shown by ls -l).
            $perms = isset($filetypes[$typebit]) ? $filetypes[$typebit][0] : 'u';
            $perms .= (($filemode & 0x0100) ? 'r' : '-') . (($filemode & 0x0080) ? 'w' : '-');
            $perms .= (($filemode & 0x0040) ? (($filemode & 0x0800) ? 's' : 'x') : (($filemode & 0x0800) ? 'S' : '-'));
            $perms .= (($filemode & 0x0020) ? 'r' : '-') . (($filemode & 0x0010) ? 'w' : '-');
            $perms .= (($filemode & 0x0008) ? (($filemode & 0x0400) ? 's' : 'x') : (($filemode & 0x0400) ? 'S' : '-'));
            $perms .= (($filemode & 0x0004) ? 'r' : '-') . (($filemode & 0x0002) ? 'w' : '-');
            $perms .= (($filemode & 0x0001) ? (($filemode & 0x0200) ? 't' : 'x') : (($filemode & 0x0200) ? 'T' : '-'));

            // Push symbolic notation
            $stat['perms'] = $perms;
        }

        return $stat;
    }

    // --- PUBLIC METHODS ---

    /**
     * Checks for known CMS and plugin vulnerabilities using textual knowledge base.
     * @return bool
     */
    function checkVulnerableCMSPlugins()
    {
        // Use results class
        $cwisResults = new \App\Library\CwisResults();
        $cwisResults->setResults($this->results);

        // Get detected CMS list (can't use method chaining in PHP4)
        $cwisResults->select('DetectedCMS');
        $cms_list = $cwisResults->get();

        // Get detected plugins list (method chaining added in PHP5)
        $cwisResults->select('DetectedPlugins');
        $plugin_list = $cwisResults->get();

        // Init and run vulnerabilities detector
        $cwisVulnDetector = new CwisVulnDetector();
        $cwisVulnDetector->construct($this->config, $cwisResults, 'Vulnerable');
        return $cwisVulnDetector->checkVulnerableCMSPlugins($cms_list, $plugin_list);
    }

    /**
     * Checks file contents for trojans, viruses, malware and other threats.
     */
    function checkFileContent($file_name = '', $file_index = 0, $file_contents = '', $file_stat = array())
    {
        // Initialize threat checks methods
        $cwisThreatChecks = new CwisThreatChecks();
        $cwisThreatChecks->construct($this);

        // Pass info about file to check
        $cwisThreatChecks->file_index = $file_index;
        $cwisThreatChecks->file_name = $file_name;
        $cwisThreatChecks->file_contents = $file_contents;
        $cwisThreatChecks->file_stat = $file_stat;

        // File extension in lowercase
        $cwisThreatChecks->file_ext = strtolower(pathinfo($file_name, PATHINFO_EXTENSION));

        // Check for vulnerabilities in files
        if ($cwisThreatChecks->checkVulnerability()) {
            $this->addCheckResultsIndirect('Vulnerable', $cwisThreatChecks->getResultEntryData());
            return true;
        }

        // --- MALWARE ---
        //
        // Web shells (backdoors) check
        if ($cwisThreatChecks->checkWebShells()) {
            $this->addCheckResultsIndirect('WebShells', $cwisThreatChecks->getResultEntryData());
            return true;
        }

        // Server malware check
        if ($cwisThreatChecks->checkCriticalPHP() || $cwisThreatChecks->checkCriticalPHPCustom()) {
            $this->addCheckResultsIndirect('CriticalPHP', $cwisThreatChecks->getResultEntryData());
            return true;
        }

        // Critical JS check
        if ($cwisThreatChecks->checkCriticalJS()) {
            $this->addCheckResultsIndirect('CriticalJS', $cwisThreatChecks->getResultEntryData());
            return true;
        }

        // Phishing attack check
        if ($cwisThreatChecks->checkPhishing()) {
            $this->addCheckResultsIndirect('Phishing', $cwisThreatChecks->getResultEntryData());
            return true;
        }

        // Htaccess and hidden files
        if ($cwisThreatChecks->checkHiddenFiles()) {
            // Check .htaccess file for malicious code
            if (stripos($file_name, 'htaccess') && $cwisThreatChecks->checkHtaccess()) {
                $this->addCheckResultsIndirect('Htaccess', $cwisThreatChecks->getResultEntryData());
            } else {
                // Warn about the hidden linux's file (limit max entries count)
                $this->addCheckResultsIndirect('HiddenFiles', $cwisThreatChecks->getResultEntryData(), false,
                    State::cnf('CWIS_MAX_EXTERNAL_LINKS'));
            }
            return true;
        }

        // --- SPYWARE/ADWARE ---
        //
        // Check for AdWare
        if ($cwisThreatChecks->checkAdware()) {
            $this->addCheckResultsIndirect('AdwareList', $cwisThreatChecks->getResultEntryData());
            return true;
        }

        // Check empty (SEO) links
        if ($cwisThreatChecks->checkEmptyLinks()) {
            $this->addCheckResultsIndirect('EmptyLinks', $cwisThreatChecks->getResultEntryData());
            return true;
        }

        // Professional features
        if ($this->config->scan_level >= 3) {

            // Check iFrames for injections
            if ($cwisThreatChecks->checkIframeInjections()) {
                $this->addCheckResultsIndirect('Iframer', $cwisThreatChecks->getResultEntryData());
                return true;
            }

            // Check content for private IP addresses
            if ($cwisThreatChecks->checkPrivateIP()) {
                $this->addCheckResultsIndirect('PrivateIP', $cwisThreatChecks->getResultEntryData());
                return true;
            }

            // Potentially malicious PHP/JS code check
            if ($cwisThreatChecks->checkMaliciousCode()) {
                $this->addCheckResultsIndirect('MaliciousCode', $cwisThreatChecks->getResultEntryData(),
                    ($cwisThreatChecks->priority >= 100));
                return true;
            }

            // Check for PHP code inside any type of a file
            if ($cwisThreatChecks->checkPHPCode()) {
                $this->addCheckResultsIndirect('PHPCodeInside', $cwisThreatChecks->getResultEntryData());
                return true;
            }
        }

        // Recommended features
        if ($this->config->scan_level >= 2) {

            // Unix executables (check by extensions list)
            if (is_array($this->executable_files) && in_array($cwisThreatChecks->file_ext, $this->executable_files)) {
                $this->addCheckResultsIndirect('UnixExec', $cwisThreatChecks->getResultEntryData());
                return true;
            }

            // Heuristic checks
            if ($cwisThreatChecks->checkHeuristic()) {
                $this->addCheckResultsIndirect('Heuristic', $cwisThreatChecks->getResultEntryData());
                return true;
            }
        }

        return false;
    }

    function checkFileCodeVulner($file_name = '', $file_index = 0, $file_contents = '', $file_stat = array())
    {
        // Check PHP code for potential vulnerabilities
        if ($this->tokenizer_loaded && false !== strpos($file_contents, '<?')) {

            // Initialize threat checks methods
            $cwisThreatChecks = new CwisThreatChecks();

            ini_set('short_open_tag', 1);   // who knows if I use them ;)
            ini_set('auto_detect_line_endings', 1); // detect newlines in MAC files

            if(!defined('MAXTRACE') && !defined('T_INCLUDE_END')) {
              define('MAXTRACE', 30);  // maximum of parameter traces per sensitive sink
              define('PHPDOC', 'http://php.net/'); // PHP documentation link
              define('MAX_ARRAY_ELEMENTS', 50);  // maximum array(1,2,3,4,...) elements to be indexed
              define('MAX_ARRAY_KEYS', 10);   // maximum array key $array[1][2][3][4]..
              define('PRELOAD_SHOW_LINE', 500);  // every X line a preloader information is added
              define('SCAN_REGISTER_GLOBALS', false); // EXPERIMENTAL: scan as if register_globals=on
              define('T_INCLUDE_END', 380);
            }

            // Check for vulnerabilities
            $scan = new CwisSec();
            $scan->construct($file_name, $file_contents);
            $scan->parse_vars();

            // Match newline positions
            $line_matches = array();
            preg_match_all("/\n/", $file_contents, $line_matches, PREG_OFFSET_CAPTURE);

            // Process scan results
            $func_matches = array();
            $lines = $this->getFileVulnerLines($scan->rips_scan->result_output, $line_matches, $file_contents);
            foreach ($scan->rips_scan->result_output as $result_output) {
                foreach ($result_output as $var_declare) {
                    $treenode = $var_declare->treenodes[0];
                    $line_no = $treenode->lines[0];
                    $line_pos = $line_matches[0][min(0, $line_no - 1)][1];
                    $func_regex = "~\b" . $treenode->name . "[@\&\s]*[\$A-Z\(\'\"\+\-\*\/]~s";
                    if (preg_match($func_regex, $file_contents, $func_matches, PREG_OFFSET_CAPTURE, $line_pos)) {
                        $marker_pos = $func_matches[0][1];
                        $vuln_description = strtoupper($treenode->name) . ' : ' . $var_declare->category . ' : ' . $treenode->title;
                        $code_fragment = $cwisThreatChecks->getFragment($file_contents, $marker_pos);
                        $entry_data = array(
                            'id'		 => $file_index,
                            'name'		 => $file_name,
                            'fragment'	 => $vuln_description . " <br />" . $code_fragment,
                            'sig'		 => null,
                            'lines'		 => $lines,
                            'stat'		 => $file_stat
                        );
                        $this->addCheckResultsIndirect('VulnerCode', $entry_data);
                        return true;
                    }
                }
            }
        }

        return false;
    }

    private function getFileVulnerLines($resultOutput, $lineMatches, $fileContents)
    {
        $lines = [];

        $cwisThreatChecks = new CwisThreatChecks();

        foreach ($resultOutput as $result_output) {
            foreach ($result_output as $var_declare) {
                $treenode = $var_declare->treenodes[0];
                $line_no = $treenode->lines[0];
                $line_pos = $lineMatches[0][min(0, $line_no - 1)][1];
                $func_regex = "~\b" . $treenode->name . "[@\&\s]*[\$A-Z\(\'\"\+\-\*\/]~s";
                if (preg_match($func_regex, $fileContents, $func_matches, PREG_OFFSET_CAPTURE, $line_pos)) {
                    $marker_pos = $func_matches[0][1];
                    $vuln_description = strtoupper($treenode->name) . ' : ' .
                        $var_declare->category . ' : ' . $treenode->title;
                    $code_fragment = $cwisThreatChecks->getFragment($fileContents, $marker_pos);

                    $marker_line_no = substr_count(substr($fileContents, 0, $marker_pos), "\n") + 1;
                    $lines[] = ['line' => $marker_line_no, 'offset' => $line_pos,
                        'fragment' => $vuln_description . " <br />" . $code_fragment];
                }
            }
        }

        return $lines;
    }

    function checkWhitelist()
    {
        // Get result checksums
        $entry_crc_list = $this->results->filterByKey('crc');

        // Get list of hashes
        $hash_list = $this->whitelist->checkHashes($entry_crc_list);
        $this->queue->statistics['whitelist'] = $this->whitelist->getSize();

        // Skip if empty
        if (empty($hash_list)) {
            return null;
        }

        // List of resuls vars to check
        $vars_to_check = array(
            // --- VULNERABILITIES ---
            'Vulnerable', 'VulnerCMS',
            // --- CRITICAL ---
            'CriticalJS', 'CriticalPHP', 'Htaccess',
            'Phishing', 'WebShells',
            // --- INFO ---
            'HiddenFiles', 'NotRead', 'SymLinks',
            // --- WARNINGS ---
            'AdwareList', 'Doorways', 'EmptyLinks', 'Heuristic', 'Iframer',
            'MaliciousCode', 'VulnerCode', 'PHPCodeInside', 'PrivateIP', 'UnixExec',
        );

        // Prepare results class
        $cwisResults = new \App\Library\CwisResults();
        $var_name = $key = ''; // initialize VAR_NAME and KEY
        //
        // Check for whitelisted scan results
        foreach ($hash_list as $hash) {
            // Get entry index(es) by hash
            $entry_indexes = array_keys($entry_crc_list, $hash);
            if (empty($entry_indexes)) {
                continue;
            }

            // Convert entry indexes
            foreach ($entry_indexes as $entry_index) {
                $var_name = $key = ''; // TODO: remove on next version update
                if ($entry_index && $cwisResults->convertEntryIndex($entry_index, $var_name, $key)) {

                    // Remove results found in whitelist
                    if ($var_name && in_array($var_name, $vars_to_check)) {
                        $this->moveCheckResultsToWhitelisted($var_name, $key);
                    }
                }
            }
        }

        // Remove duplicates and optimize results
        foreach ($vars_to_check as $var_name) {
            $this->results->unique($var_name);
            $this->results->optimize($var_name);
        }
    }

    function detectCMSPlugins($dir_list = array())
    {
        // New instance of plugins detector
        $pluginsDetector = new CwisPluginsDetector();

        // Constructor with PHP 4 support
        $pluginsDetector->construct($this->config);

        // Check directories list
        $pluginsDetector->checkDirectories($dir_list);

        // Select detected plugins list
        $this->results->select('DetectedPlugins');

        // Get list of plugins found
        $pluginsDetected = $pluginsDetector->getPlugins();
        foreach ($pluginsDetected as $plugin_path => $plugin_detected) {
            $plugin_path_packed = $this->utilities->filenameShrink($plugin_path);
            $this->results->add($plugin_path_packed, $plugin_detected); //HTML encoding was removed due to bugs
        }
    }

    function detectCMSVersion($dir_list = array())
    {
        // New instance of version detector
        $cmsListDetector = new CwisCmsDetector();

        // Constructor with PHP 4 support
        $cmsListDetector->construct($this->config);

        // Get directories list
        if (empty($dir_list)) {
            $dir_list = $cmsListDetector->getDirList(State::scanPath());
            $dir_list[] = State::scanPath();
        }

        // Check directories
        $cmsListDetector->checkDirectories($dir_list);

        // Select detected CMS list
        $this->results->select('DetectedCMS');
        $results = array();

        // Get CMS version
        $cmsDetectedNum = $cmsListDetector->getCmsNumber();
        for ($tt = 0; $tt < $cmsDetectedNum; $tt++) {
            $cms_root_path = $cmsListDetector->getCmsPath($tt);
            $cms_name_version = $cmsListDetector->getCmsName($tt) . "\t" . $cmsListDetector->getCmsVersion($tt);

            // Push result
            $cms_path_packed = $this->utilities->filenameShrink($cms_root_path);
            if (!isset($results[$cms_path_packed])) {
                $results[$cms_path_packed] = array();
            }
            $results[$cms_path_packed][] = $cms_name_version;
        }


        // Select detected CMS
        $this->results->set($results);
    }

    function isQueuedScanFinished($scan_offset = null)
    {
        // Use progress scan offset by default
        if (null === $scan_offset) {
            $scan_offset = $this->queue->scan['offset'];
        }

        //$progress_divider = (!$this->config->isPremium() ? 2 : 1);
        //return (bool) ($scan_offset >= $this->queue->scan['counter'] / $progress_divider);
        return (bool) ($scan_offset >= $this->queue->scan['counter']);
    }

    function queuedScanForThreats($list_offset = 0)
    {
        $this->logger->debugMessage('queuedScanForThreats(' . $list_offset . ')');

        // Scan timeout (1 second by default), subtract 2%
        $scan_timeout = /* $this->config->scan_timeout * */ .98;

        // Start the timer
        $timer = new \App\Library\CwisTimer();
        $timer->start();

        // Build a queue file name
        $this->utilities->setScanPath($this->config->getScanPath());
        $queue_filepath = $this->fnBufferGetPathToVolume($list_offset);

        // Read queue file as an array
        $files_list = file_get_array($queue_filepath);

        // Finish scan on error
        $max_offset = count($files_list);
        if (!$max_offset) { // limit scan progress to 50%
            //$progress_divider = (!$this->config->isPremium() ? 2 : 1);
            //return round($this->queue->scan['counter'] / $progress_divider);
            return $this->queue->scan['counter'];
        }

        // Define buffer volumes
        $current_volume = $this->fnBufferGetVolumeIndex($list_offset);
        $end_volume = $this->fnBufferGetVolumeIndex($this->queue->scan['counter']);

        // Define scan offsets
        $start_offset = $current_volume * $this->fn_buffer_volume;
        $end_offset = $start_offset + ($current_volume < $end_volume ? $this->fn_buffer_volume : $max_offset);

        // Free up some RAM memory
        for ($i = 0; $i < $list_offset; $i++) {
            $files_list[$i] = null;
        }

        // Start/continue from $list_offset
        for ($i = $list_offset; $i < $end_offset; $i++) {
            if ($i % 10 === 0) {
                $this->benchmark->virtualLoadBalancing();
            }

            // Should stop scan immediately on error or by request
            if ($i < 0 || $this->isQueuedScanFinished($i)) {
                break;
            }

            // Check the filename from a buffer
            $file_name_packed = $files_list[$i - $start_offset];

            // Check for file hash and drop it if needed
            if (($hash_pos = strpos($file_name_packed, "\t"))) {
                $file_name_packed = substr($file_name_packed, 0, $hash_pos);
            }

            // "Decompress" the filename
            $file_name = $this->utilities->filenameExpand($file_name_packed);

            // Mark the start time
            $time_start = microtime(true);

            // --- Scan the file ---
            $this->scanFile($file_name, $i);

            // Write info about the file's scan speed
            if (State::cwisDebug() >= 2 && is_file($file_name)) {
                $file_size = is_readable($file_name) ? @filesize($file_name) : 0;
                $time_elapsed = round(microtime(true) - $time_start, 3);
                $this->logger->scanspeedMessage($file_name_packed, $file_size, $time_elapsed);
            }

            // Point scan offset to the next file
            //$this->queue->scan['offset'] = $i + 1;
            //
            // Print progress
            if ((State::isCli() && !CWIS_IS_CGI) && !$this->config->api_mode) {
                $this->stdoutPrintProgress($file_name);
            }

            // Ckeck the timer for timeout (1 sec by default)
            if ($scan_timeout > 0 && $timer->isTimeUp($scan_timeout)) {
                return $i + 1; // break
            }
        }

        // Remove queue list in the end of scan
        /* if ($scan_timeout >= 0 && $queue_filepath && is_file($queue_filepath)) {
          unlink($queue_filepath);
          } */

        return $i;
    }

    function queuedRescanForThreats($list_offset = 0)
    {
        $this->logger->debugMessage('queuedRescanForThreats(' . $list_offset . ')');

        // Scan timeout (1 second by default), subtract 2%
        $scan_timeout = /* $this->config->scan_timeout * */ .98;

        // Start the timer
        $timer = new \App\Library\CwisTimer();
        $timer->start();

        // Build a rescan file name
        $this->utilities->setScanPath($this->config->getScanPath());
        $rescan_filepath = $this->utilities->defineFilePath('rescan');

        // Validate offset
        if ($list_offset >= 0) {

            // Read queue file as an array
            $files_list = file_get_array($rescan_filepath);
            $max_offset = count($files_list);

            // Free up some RAM memory
            for ($i = 0; $i < $list_offset; $i++) {
                $files_list[$i] = null;
            }

            // Start/continue from $list_offset
            for ($i = $list_offset; $i < $max_offset; $i++) {
                if ($i % 10 === 0) {
                    $this->benchmark->virtualLoadBalancing();
                }

                // Should stop scan immediately on error or by request
                if ($i < 0 || $i >= $this->queue->rescan['discovered'] || !isset($files_list[$i])) {
                    break;
                }

                // Get the file name from buffer, "decompressed"
                $file_name = $this->utilities->filenameExpand($files_list[$i]);

                // Check for file hash and drop it if needed
                if (($hash_pos = strpos($file_name, "\t"))) {
                    $file_name = substr($file_name, 0, $hash_pos);
                }

                // --- Rescan the file ---
                $this->scanFile($file_name, $this->queue->scan['counter'] + $i);

                // Point rescan offset to the next file
                //$this->queue->rescan['processed'] = $i + 1;
                // Print progress
                if ((State::isCli() && !CWIS_IS_CGI) && !$this->config->api_mode) {
                    $this->stdoutPrintProgress($file_name);
                }

                // Ckeck the timer for timeout (1 sec by default)
                if ($scan_timeout > 0 && $timer->isTimeUp($scan_timeout)) {
                    return $i + 1; // break
                }
            }
        }

        // Remove queue list in the end of scan
        if ($scan_timeout >= 0 && $rescan_filepath && is_file($rescan_filepath) && !State::cwisDebug()) {
            @unlink($rescan_filepath);
        }

        return -1;
    }

    function loadCustomSignatures()
    {
        // Load custom signatures
        $sig_list = file_get_array(State::makePath([State::listsPath(), '.customsig']));
        foreach ($sig_list as $line) {
            $this->signatures->g_FlexDBShe[] = preg_replace('~\G(?:[^#\\\\]+|\\\\.)*+\K#~', '\\#', $line); // escaping #
        }

        $this->logger->debugMessage('Loaded ' . count($sig_list) . ' signatures from ".customsig"');
    }

    function loadIgnoredExt()
    {
        // Set parsed ignore extensions list
        $this->results->select('IgnoredExt');
        $this->results->set(
            $this->config->parseExtList($this->config->ext_skip)
        );

        if ($this->results->count()) {
            $this->logger->debugMessage('Skip extensions: ' . implode(',', $this->results->get()));
        }
    }

    function loadIgnoredFiles()
    {

    }

    function loadIgnoreLists($force = false)
    {
        // Directories ignore list
        $this->results->select('DirIgnoreList');
        if ($force || !$this->results->count()) {
            $this->results->set(
                array_map('normalize_path',  file_get_array(State::makePath([State::listsPath(), '.dirignore'])))
            );
            $this->queue->statistics['dirignore'] = $this->results->count();
            $this->results->push(State::workPath()); // ignore our working directory
            if (State::workPath() !== State::tempPath()) { // ignore temporary files directory
                $this->results->push(State::tempPath());
            }

            // Exclude selected subdirectories
            if ($this->config->scan_dir_exclude) {
                $scan_dir_exclude = explode(',', $this->config->scan_dir_exclude);
                foreach ($scan_dir_exclude as $scan_dir_skip) {
                    $scan_dir_skip = trim($scan_dir_skip, " \t\n\r\0\u000B\\/");

                    // Push all scan paths combined with subdirs to skip
                    foreach ($this->config->getScanPaths() as $scan_path) {
                        if ($scan_path && $scan_dir_skip) { // normalize non-empty path before pushing
                            $this->results->push(
                                normalize_path($scan_path . DIRECTORY_SEPARATOR . $scan_dir_skip)
                            );
                        }
                    }
                }
            }

            $this->logger->debugMessage('Loaded ' . $this->queue->statistics['dirignore'] . ' items from ".dirignore"');
        }

        //exclude quarantine path
        $this->results->push(normalize_path(State::quarantinePath()));

        // Files ignore list
        $this->results->select('FileIgnoreList');
        if ($force || !$this->results->count()) {
            $this->results->set(
                array_map('normalize_path', file_get_array(State::makePath([State::listsPath(), '.fileignore'])))
            );
            $this->queue->statistics['fileignore'] = $this->results->count();
            $this->results->push(CWIS_ROOT_PATH . DIRECTORY_SEPARATOR . 'cwis-scan.html'); // client-side file
            $this->results->push(CWIS_ROOT_PATH . DIRECTORY_SEPARATOR . 'cwis-scan.php'); // server-side file

            $this->logger->debugMessage('Loaded ' . $this->queue->statistics['fileignore'] . ' items from ".fileignore"');
        }

        // URLs ignore list
        $this->results->select('UrlIgnoreList');
        if ($force || !$this->results->count()) {
            $this->results->set(
                file_get_array(State::makePath([State::listsPath(), '.urlignore']))
            );
            $this->results->stripComments();
            $this->queue->statistics['urlignore'] = $this->results->count();
            if ($this->config->http_host && $this->config->http_host !== 'localhost') {
                $this->results->push('://' . $this->config->http_host . '/'); // ignore own host
            }
            //
            // Adding the WWW Prefix
            $url_ignore_list = $this->results->get();
            foreach ($url_ignore_list as $url_to_ignore) {
                $url_with_www_prefix = '://www.' . substr($url_to_ignore, 3);
                $this->results->push($url_with_www_prefix);
            }

            $this->logger->debugMessage("Loaded " . $this->queue->statistics['urlignore'] . ' items from ".urlignore"');
        }

        //$this->logger->debugMemoryUsage();
    }

    function loadOptimizeSignatures()
    {
        if (!empty($this->signatures)) {
            return false;
        }

        $this->logger->debugMessage('loadOptimizeSignatures()');

        // Load and unpack signatures
        $this->signatures = new CwisSignatures();
        $this->signatures->construct($this->config);
        $this->signatures->unpack();

        // Total signatures count
        $this->queue->system['signatures'] = $this->signatures->getCount();

        // Load primary signatures
        $this->signatures->g_ExceptFlex = $this->filterExceptionRules($this->signatures->g_ExceptFlex);
        //$this->signatures->g_ExceptFlex = array_values($this->signatures->g_ExceptFlex);
        // Optimize regExp-signatures
        $this->signatures->optimize();

        return true;
    }

    // --- Prepare rescan ---

    function getPathDepth($path = '')
    {
        return substr_count($path, '/') + substr_count($path, '\\');
    }

    function preparePrescanDirNamesExpanded(&$files_diff, &$files_mod, $prescan_dir_names_expanded = array(), $modtime = 0, $scan_timeout = 0, $start_offset = 0, $base_dir_depth = 0)
    {
        if (!is_array($prescan_dir_names_expanded)) {
            $prescan_dir_names_expanded = array($prescan_dir_names_expanded);
        }

        // Start the timer
        $timer = new \App\Library\CwisTimer();
        $timer->start();

        // Process prescan directories names expanded
        foreach ($prescan_dir_names_expanded as $prescan_offset => $prescan_dir_name_expanded) {

            // Proceed to start offset or check if directory is not in the ignore list
            if ($start_offset > $prescan_offset || $this->isDirectoryInIgnoreList(normalize_path($prescan_dir_name_expanded) . DIRECTORY_SEPARATOR)) {
                continue;
            }

            // Read the realpath and detect symlinks (works in WIN)
            $prescan_dir_name_real = file_exists($prescan_dir_name_expanded) ? realpath($prescan_dir_name_expanded) : $prescan_dir_name_expanded;
            if ($prescan_dir_name_real !== $prescan_dir_name_expanded) {
                if (State::cnf('follow_symlinks')) {
                    $prescan_dir_name_expanded = $prescan_dir_name_real; // set to realpath value
                } else {
                    continue; // do not follow symlinks
                }
            }

            // Set pre-prescan progress path
            $this->queue->setProgress($prescan_dir_name_expanded . DIRECTORY_SEPARATOR);

            // Scan directory files
            $filenames = scan_dir($prescan_dir_name_expanded);
            if (!$filenames || !is_array($filenames)) {
                continue;
            }

            // Check for files modifications
            foreach ($filenames as $filename) {
                if (!is_dir($filename)) {

                    // Check if file is not in the ignore list
                    if ($this->isFileInIgnoreList($filename)) {
                        continue;
                    }

                    // Calculate SHA1 hashes
                    if ($this->config->scan_modified) {
                        // Get filename "compressed" a bit
                        $file_name_buffered = $this->utilities->filenameShrink($filename);

                        // Attach the SHA1 hash of a file
                        $file_hash = $this->utilities->filenameSha1($filename);
                        $file_name_buffered .= "\t" . $file_hash;

                        // Pass buffered file name
                        $files_diff[] = $file_name_buffered;
                    } else
                        if ($modtime && filemtime($filename) > $modtime) {
                            // Get filename "compressed" and treat as modified
                            $files_mod[] = $this->utilities->filenameShrink($filename);
                        }
                } else {
                    // Check scan depth level
                    $current_dir_depth = $this->getPathDepth($filename);
                    if ($this->config->scan_depth < 0 || $current_dir_depth < $base_dir_depth + $this->config->scan_depth) {

                        // Shrink dir names (old QUEUE filenames are already shrinked)
                        $files_diff[] = $this->utilities->filenameShrink($filename . DIRECTORY_SEPARATOR);

                        // Detect and process new directories (don't add trailing slash)
                        if (!in_array($filename, $prescan_dir_names_expanded)) {
                            $this->preparePrescanDirNamesExpanded($files_diff, $files_mod, $filename, $modtime, $scan_timeout, 0);
                        }
                    }
                }
            }
            unset($filenames);

            // Ckeck the timer for timeout (1 sec by default)
            if ($scan_timeout > 0 && $timer->isTimeUp($scan_timeout)) {
                break;
            }
        }

        return $prescan_offset + 1;
    }

    function prepareRescanModifiedFiles()
    {
        // Define modtime
        $queue_filepath = $this->utilities->defineFilePath('queue');
        $modtime = is_file($queue_filepath) ? filemtime($queue_filepath) : 0;

        // Restore prescan directories list from a file
        $prescan_filepath = $this->utilities->defineFilePath('prescan');
        $prescan_dir_names = file_get_array($prescan_filepath);

        // Expand prescan directories names
        $prescan_dir_names_expanded = $this->utilities->filenameExpand($prescan_dir_names);
        unset($prescan_dir_names);

        // Get the first directory name
        $root_prescan_dir_name_expanded = reset($prescan_dir_names_expanded);

        // Directories prescan depth
        $base_dir_depth = $this->getPathDepth($root_prescan_dir_name_expanded);

        // Different (added or removed) and modified files
        $files_diff = $files_mod = array();

        // Scan timeout (1.5 seconds by default), subtract 2%
        $scan_timeout = /* $this->config->scan_timeout * */ 1.5 * .98;
        //
        // Process prescan directories names recursively
        $this->queue->rescan['counter'] = count($prescan_dir_names_expanded);
        $this->queue->rescan['offset'] = $this->preparePrescanDirNamesExpanded($files_diff, $files_mod,
            $prescan_dir_names_expanded, $modtime, $scan_timeout, $this->queue->rescan['offset'], $base_dir_depth);

        // Compare with old QUEUE files (volumes)
        for ($volume_index = 0; $volume_index < 1000; $volume_index++) {
            $queue_filepath = $this->utilities->defineFilePath('queue' . ($volume_index ? $volume_index : ''));
            if (!is_file($queue_filepath) || !is_readable($queue_filepath)) {
                break;
            }

            // Compare files and keep the difference only
            $files_diff = array_diff($files_diff, file_get_array($queue_filepath));
        }

        // Filter directories
        foreach ($files_diff as $index => $filename_shrinked) {
            if ($filename_shrinked === '.' || substr($filename_shrinked, -1) === DIRECTORY_SEPARATOR) {
                unset($files_diff[$index]);
            }
        }

        // Update counter of files found
        $this->queue->scan['files']['found'] += count($files_diff);

        // Update counter of files scanned
        $this->queue->scan['files']['scanned'] -= count($files_mod);

        return array_merge($files_diff, $files_mod);
    }

    function prepareRescanForThreats()
    {
        // List of non-critical scan results (no need to rescan)
        $vars_to_rescan = array(
            // --- VULNERABILITIES ---
            'Vulnerable', 'VulnerCMS',
            // --- CRITICAL ---
            'CriticalJS', 'CriticalPHP', 'Htaccess',
            'Phishing', 'WebShells',
            // --- INFO ---
            'HiddenFiles', 'NotRead', 'SymLinks', 'Whitelisted',
            // --- WARNINGS ---
            'AdwareList', 'EmptyLinks', 'Heuristic', 'Iframer',
            'MaliciousCode', 'VulnerCode', 'PHPCodeInside', 'PrivateIP', 'UnixExec',
        );

        // Entry details (DEPRECATED)
        $this->results->select('EntryDetails');
        $entry_details_list = $this->results->get();

        // Prepare rescan files list
        $rescan_files_list = array();
        foreach ($this->results->all() as $var => $array) {
            if (!is_array($array) || !in_array($var, $vars_to_rescan)) {
                continue;
            }

            foreach ($array as $key => $entry_data) {
                if (isset($entry_data['name'])) {
                    $entry_name = $entry_data['name'];
                } else {
                    $entry_name = null;

                    if (!empty($entry_details_list)) {
                        // Arrays support in reports (DEPRECATED)
                        $file_index = isset($entry_data['file']) ? $entry_data['file'] : $entry_data;
                        if (is_array($file_index)) {
                            continue;
                        }

                        // Evaluate numeric indexes to corresponding values
                        if (is_numeric($file_index) && isset($entry_details_list[$file_index])) {
                            // Get a packed filename
                            $entry_details = $entry_details_list[$file_index];
                            $entry_separator_pos = strpos($entry_details, "\t");
                            if (false === $entry_separator_pos) {
                                $entry_name = $entry_details;
                            } else {
                                $entry_name = substr($entry_details, 0, $entry_separator_pos);
                            }
                        } else {
                            $entry_name = null;
                        }
                    }
                }

                // Push non-empty string filename, skip PDO (database) records
                if (is_string($entry_name) && !$this->utilities->filenameIsPdoRecord($entry_name)) {
                    $rescan_files_list[] = $entry_name;
                }

                // Unset scan (report) results
                $this->results->select($var);
                $this->results->delete($key);
            }
        }

        // Optimize files list using faster analog of array_unique
        $optimized_scan_files_list = !empty($rescan_files_list) ? array_keys(array_flip($rescan_files_list)) : array();

        // Set pre-prescan progress path
        if (isset($entry_name) && $entry_name) {
            $this->queue->setProgress($this->utilities->filenameExpand($entry_name));
        }

        // Reset counters of scanned directories and files
        foreach ($optimized_scan_files_list as $file_name) {
            if ($file_name && substr($file_name, -1) === DIRECTORY_SEPARATOR) {
                $this->queue->scan['directories']['scanned'] --;
            } else {
                $this->queue->scan['files']['scanned'] --;
            }
        }

        return $optimized_scan_files_list;
    }

    // --- Process prescaned dirs ---

    function fnBufferGetVolumeIndex($fn_list_offset = 0)
    {
        return floor($fn_list_offset / $this->fn_buffer_volume);
    }

    function fnBufferGetPathToVolume($fn_list_offset = 0)
    {
        $volume_index = $this->fnBufferGetVolumeIndex($fn_list_offset);
        return $this->utilities->defineFilePath('queue' . ($volume_index ? $volume_index : ''));
    }

    function fnBufferSaveVolume($fn_buffer = '', $fn_list_offset = 0)
    {
        $queue_filepath = $this->fnBufferGetPathToVolume($fn_list_offset);
        return file_put_contents_safe($queue_filepath, $fn_buffer, FILE_APPEND | LOCK_EX);
    }

    function fnBufferSplitToVolumes(&$fn_buffer)
    {
        // Dump the buffer before the next volume starts
        $should_dump_buffer = ($fn_buffer && ($this->queue->scan['counter']) % $this->fn_buffer_volume === 0);

        // Save data to file (dump file names)
        if ($should_dump_buffer || strlen($fn_buffer) > 21000) {
            if ($this->fnBufferSaveVolume($fn_buffer, $this->queue->scan['counter'] - 1)) {
                $fn_buffer = '';
            }
        }
    }

    function isDirectoryInIgnoreList($dir_normalized = '')
    {
        // Check if directory is in the ignore list
        $skip_directory_on_ignore = false;
        $this->results->select('DirIgnoreList');
        foreach ($this->results->get() as $dir_ignore) {

            // Support for wildcards "**" and "*"
            if (false !== strpos($dir_ignore, '*')) {
                $regex_quoted = '#' . preg_quote($dir_ignore, '#') . '#';
                $regex = str_replace(array('\*\*', '\*'), array('.+', '[^' . preg_quote(DIRECTORY_SEPARATOR) . ']+'), $regex_quoted);
                if (preg_match($regex, $dir_normalized)) {
                    $skip_directory_on_ignore = true;
                    break;
                }
            }

            // Directory match
            if (false !== stripos($dir_normalized, $dir_ignore)) {
                $skip_directory_on_ignore = true;
                break;
            }
        }

        return $skip_directory_on_ignore;
    }

    function isFileInIgnoreList($file_normalized = '')
    {
        // Check if file is in the ignore list
        $skip_file_on_ignore = false;
        $this->results->select('FileIgnoreList');
        foreach ($this->results->get() as $file_ignore) {

            // File match
            if (false !== stripos($file_normalized, $file_ignore)) {
                $skip_file_on_ignore = true;
                break;
            }
        }

        return $skip_file_on_ignore;
    }

    function processPrescanedDirectories($prescan_data = array())
    {
        // File names buffer
        $fn_buffer = '';

        // Scan timeout (1 second by default), subtract 1%
        $scan_timeout = /* $this->config->scan_timeout * */ .99;

        // Start the timer
        $timer = new \App\Library\CwisTimer();
        $timer->start();

        // Set path to a queue file name (CWIS-QUEUE.dat)
        $this->utilities->setScanPath($this->config->getScanPath());

        $directories_counter = 0;
        $doorway_files_counter = 0;
        $doorway_file_name = '';

        $this->logger->debugMessage('processPrescanedDirectories()');

        // Process pre-scanned directories
        while ($this->queue->prescan['processed'] < $this->queue->prescan['discovered'] &&
            isset($prescan_data[$this->queue->prescan['processed']])) {

            // Split file names buffer by volumes
            $this->fnBufferSplitToVolumes($fn_buffer);

            // Get a new directory from a prescanned
            $root_directory_packed = $prescan_data[$this->queue->prescan['processed']];
            $root_directory = $this->utilities->filenameExpand($root_directory_packed);
            $this->queue->prescan['processed'] ++;

            // Analyse directory
            if (!$root_directory || !is_dir($root_directory)) {
                if (is_file($root_directory)) {
                    // Pass file name to buffer, "compressed" a bit
                    $fn_buffer .= $this->utilities->filenameShrink($root_directory) . "\n";

                    $this->queue->scan['counter'] ++;
                    $this->queue->scan['files']['found'] ++;
                    $this->logger->debugMessage('Add file "' . $root_directory_packed . '" directly');
                } else {
                    $this->logger->debugMessage('Cannot read directory "' . $root_directory_packed . '"');
                }
                continue;
            } elseif (State::cwisDebug() >= 2) {
                $this->logger->debugMessage('Process directory "' . $root_directory_packed . '"');
            }

            // Normalized path
            $root_directory_normalized = normalize_path($root_directory) . DIRECTORY_SEPARATOR;

            // Check if directory is in the ignore list
            $skip_directory_on_ignore = $this->isDirectoryInIgnoreList($root_directory_normalized);

            // Read the realpath and detect symlinks (works in WIN)
            $root_directory_real = file_exists($root_directory_normalized) ? realpath($root_directory_normalized) . DIRECTORY_SEPARATOR : $root_directory_normalized;
            if ($root_directory_real !== $root_directory_normalized) {
                if (State::cnf('CWIS_FOLLOW_SYMLINKS')) {
                    $root_directory_normalized = $root_directory_real; // set to realpath value
                } else {

                    // Pass to buffer a "dot" as a name (can't be empty)
                    $fn_buffer .= ".\n";
                    $directories_counter++;

                    // Pass "compressed" dir name to results
                    $result_file_name = $this->utilities->filenameShrink($root_directory_normalized);
                    $result_entry_data = array('id'	 => $this->queue->scan['counter'], 'name'	 => $result_file_name,
                        'stat'	 => $this->cachedFileStat($root_directory_normalized));
                    $this->addCheckResultsIndirect('SymLinks', $result_entry_data);
                    $this->logger->debugMessage('Skip symbolic link "' . $result_file_name . '"');

                    $this->queue->scan['counter'] ++;
                    $this->queue->scan['directories']['found'] ++;
                    $this->queue->scan['directories']['skipped'] ++;
                    continue; // do not follow symlinks
                }
            }

            // Skip if matched by ignore lists
            if ($skip_directory_on_ignore) {

                // Pass to buffer a "dot" as a name (can't be empty)
                $fn_buffer .= ".\n";
                $directories_counter++;

                // Pass "compressed" dir name to results
                $result_file_name = $this->utilities->filenameShrink($root_directory_normalized);
                $result_entry_data = array('id'	 => $this->queue->scan['counter'], 'name'	 => $result_file_name,
                    'stat'	 => $this->cachedFileStat($root_directory_normalized));
                $this->addCheckResultsIndirect('SkippedDirs', $result_entry_data, false, State::cnf('CWIS_MAX_EXTERNAL_LINKS'));
                $this->logger->debugMessage('Skip ignored directory "' . $result_file_name . '"');

                $this->queue->scan['counter'] ++;
                $this->queue->scan['directories']['found'] ++;
                $this->queue->scan['directories']['skipped'] ++;
                continue;
            }

            // Set prescan progress path
            $this->queue->setProgress($root_directory_normalized);

            // Read dir's files list
            $file_names = scan_dir($root_directory);

            // Process files, skipping "." and ".."
            foreach ($file_names as $file_name) {
                $path_parts = pathinfo($file_name);
                /* if ($path_parts['basename'] === '.' || $path_parts['basename'] === '..') {
                  continue;
                  } */

                // Split file names buffer by volumes and save data to file
                $this->fnBufferSplitToVolumes($fn_buffer);

                // Is directory?
                if (is_dir($file_name)) {
                    $dir_name = $file_name . DIRECTORY_SEPARATOR;

                    // Pass dir name to buffer, "compress" it a bit
                    $fn_buffer .= $this->utilities->filenameShrink($dir_name) . "\n";
                    $directories_counter++;

                    // Doorway detected
                    if ($this->config->scan_level >= 3 && $directories_counter > CWIS_MAX_ALLOWED_PHP_HTML_IN_DIR) {
                        $result_file_name = $this->utilities->filenameShrink($dir_name);
                        $result_entry_data = array('id'	 => $this->queue->scan['counter'], 'name'	 => $result_file_name,
                            'stat'	 => $this->cachedFileStat($dir_name));
                        $this->addCheckResultsIndirect('Doorways', $result_entry_data);
                        //$g_Doorway[$file_name] = $this->queue->scan['counter']; //$file_name; //$sourceDirIndex;
                        $directories_counter = 0;
                    }

                    $doorway_files_counter = 0;
                    $doorway_file_name = '';

                    $file_need_to_scan = false;

                    $this->queue->scan['counter'] ++;
                    $this->queue->scan['directories']['found'] ++;
                } else {

                    // Check the file extension
                    $file_ext = isset($path_parts['extension']) ? strtolower($path_parts['extension']) : '';
                    if ($this->exclusive_files) {
                        // ONLY exclusive extensions to scan
                        $file_need_to_scan = in_array($file_ext, $this->exclusive_files);
                    } else {
                        // Scan all files or sensitive/executable files ONLY
                        $file_need_to_scan = $this->config->scan_all_files ||
                            in_array($file_ext, $this->sensitive_files) ||
                            in_array($file_ext, $this->executable_files);
                    }

                    // Check if extension isn't in ignore list
                    $this->results->select('IgnoredExt');
                    if ($this->results->count() && in_array($file_ext, $this->results->get())) {
                        $file_need_to_scan = false;
                    }
                }

                if ($file_need_to_scan) {
                    $this->results->select('FileIgnoreList');
                    if ($this->results->count()) {

                        // Check if file is in the ignore list
                        $skip_file_on_ignore = false;
                        foreach ($this->results->get() as $file_ignore) {
                            if (false !== stripos($file_name, $file_ignore)) {
                                $skip_file_on_ignore = true;
                                break;
                            }
                        }

                        // Skip if matched by ignore lists
                        if ($skip_file_on_ignore) {

                            // Pass to buffer a "dot" as a name (can't be empty)
                            $fn_buffer .= ".\n";

                            // Pass "compressed" file name to results
                            $result_file_name = $this->utilities->filenameShrink($file_name);
                            $result_entry_data = array('id'	 => $this->queue->scan['counter'], 'name'	 => $result_file_name,
                                'stat'	 => $this->cachedFileStat($file_name));
                            $this->addCheckResultsIndirect('SkippedDirs', $result_entry_data);
                            $this->logger->debugMessage('Skip ignored file "' . $result_file_name . '"');

                            $this->queue->scan['counter'] ++;
                            $this->queue->scan['files']['found'] ++;
                            $this->queue->scan['files']['skipped'] ++;
                            continue;
                        }
                    }

                    // Detect doorway files
                    if (in_array($file_ext, $this->short_list_ext)) {
                        $doorway_files_counter++;

                        // Doorway detected?
                        if ($this->config->scan_level >= 3 && $doorway_files_counter > CWIS_MAX_ALLOWED_PHP_HTML_IN_DIR / 3) {

                            // Primary doorway filename
                            if (empty($doorway_file_name)) {
                                $doorway_file_name = $file_name;
                            } elseif ($doorway_files_counter > CWIS_MAX_ALLOWED_PHP_HTML_IN_DIR / 2) {

                                // Get two files contents difference
                                $cwisDifference = new \App\Library\CwisDifference();
                                $difference = $cwisDifference->compare(
                                    file_get_contents($doorway_file_name), file_get_contents($file_name)
                                );

                                // Assume that file is the part of doorway...
                                if ($difference < .42) {
                                    // ...if the difference between two files is less than 42%
                                    $dir_name = $path_parts['dirname'];
                                    $result_file_name = $this->utilities->filenameShrink($dir_name);
                                    $result_entry_data = array('name'	 => $result_file_name,
                                        'stat'	 => $this->cachedFileStat($dir_name));
                                    $this->addCheckResultsIndirect('Doorways', $result_entry_data);
                                    //$g_Doorway[$file_name] = $this->queue->scan['counter']; //$file_name; //$sourceDirIndex;
                                }

                                $doorway_files_counter = 0;
                                $doorway_file_name = '';
                            }
                        }
                    }

                    // Get filename "compressed" a bit
                    $file_name_buffered = $this->utilities->filenameShrink($file_name);

                    // Attach the SHA1 hash of a file
                    if ($this->config->scan_modified) {
                        $file_hash = $this->utilities->filenameSha1($file_name);
                        $file_name_buffered .= "\t" . $file_hash;
                    }

                    // Pass file name to buffer
                    $fn_buffer .= $file_name_buffered . "\n";

                    $this->queue->scan['counter'] ++;
                    $this->queue->scan['files']['found'] ++;
                }
            }
            unset($file_names);

            // Print progress
            if ((State::isCli() && !CWIS_IS_CGI) && !$this->config->api_mode) {
                $this->stdoutPrintProgress($root_directory);
            }

            // Ckeck the timer for timeout (1 sec by default)
            if ($scan_timeout > 0 && $timer->isTimeUp($scan_timeout)) {
                break;
            }

            // Virtual load balancing
            $this->benchmark->virtualLoadBalancing();
        }

        // Split file names buffer by volumes and save data to file
        if (!empty($fn_buffer) && !$this->fnBufferSaveVolume($fn_buffer, $this->queue->scan['counter'] - 1)) {
            header('HTTP/1.0 500 Internal Server Error');
            die('Cannot write queued list to file.');
        }
    }

    /**
     * Prints scan progress in CLI mode.
     * @param int $file_name Current file name
     */
    function stdoutPrintProgress($file_name = '')
    {
        // Update config data, scan progress, timers...
        $this->queue->updateProgress($this->config);

        // Progress percent
        if (!$this->queue->isRescanFinished()) {
            // Rescan in progress...
            $progress = 'Rescan: ' . round($this->queue->prescan['percent'] * .1)
                . '% + ' . round($this->queue->rescan['percent'] * .9) . '%';
        } else
            if (!$this->queue->isScanFinished()) {
                // Scan in progress...
                $progress = 'Scan: ' . round($this->queue->prescan['percent'] * .1)
                    . '% + ' . round($this->queue->scan['percent'] * .9) . '%';
            }

        // File name and percent
        $file_name_ending = substr($file_name, -60);
        $message = $progress . ' [' . $file_name_ending . ']';
        $message .= ' [' . $this->queue->scan['speed'] . ' files/sec]';
        if ($this->queue->time['left'] > 0) {
            $message .= ' [Left ' . $this->utilities->formatSeconds($this->queue->time['left']) . ']';
        }
        //' [Mlw:' . (count($g_CriticalPHP) + count($g_Base64)) . '|' . (count($g_CriticalJS) + count($g_Iframer) + count($g_Phishing)) . ']';

        $message_padded = str_pad($message, 160, ' ', STR_PAD_RIGHT);
        \App\Library\CwisStaticHelpers::cwis_stdout_message(str_repeat(chr(8), 160) . $message_padded, false);
    }

    // --- DATABASE SCAN ---

    function databaseCloseConnection()
    {
        // Close a PDO handle and clean up memory
        $this->pdo = null;
        unset($this->pdo);
    }

    /**
     * Returns the latest database error message.
     * @return type
     */
    function databaseGetErrorMessage()
    {
        return $this->pdo ? $this->pdo->errorMessage : '';
    }

    /**
     * Opens a connection to the database.
     * @param string $dbtype
     * @param string $dbhost
     * @param string $dbuser
     * @param string $dbpass
     * @param null|string $dbname
     * @return bool
     */
    function databaseOpenConnection($dbtype = '', $dbhost = 'localhost', $dbuser = 'root', $dbpass = '', $dbname = null)
    {
        $this->pdo = new CwisPdo();
        $this->pdo->construct($dbtype);

        // Check database driver
        if (!$this->pdo->getDriver()) {
            $this->pdo->errorMessage = 'The PDO/MySQL/MySQLi extension is not installed.';
            return false;
        }

        // Connect to database
        if (!$this->pdo->connect($dbhost, $dbuser, $dbpass, $dbname)) {
            if (!$this->pdo->errorMessage) {
                $this->pdo->errorMessage = 'Cannot connect to database.';
            }
            return false;
        }

        return true;
    }

    function databaseKnownTablesCheck($dbname = '*', $dbprefix = '')
    {
        // Known Wordpress tables
        $wordpress_tables = array('blogs', 'blog_versions', 'categories', 'commentmeta',
            'comments', 'link2cat', 'links', 'options', 'post2cat', 'postmeta', 'posts',
            'registration_log', 'signups', 'sitemeta', 'site', 'termmeta', 'terms',
            'term_relationships', 'term_taxonomy', 'usermeta', 'users');

        // Known Drupal tables
        $drupal_tables = array('actions', 'authmap', 'backup_migrate_destinations',
            'backup_migrate_profiles', 'backup_migrate_schedules', 'batch',
            'block', 'block_custom', 'block_node_type', 'block_role', 'blocked_ips',
            'cache', 'cache_block', 'cache_bootstrap', 'cache_field', 'cache_filter',
            'cache_form', 'cache_image', 'cache_libraries', 'cache_menu',
            'cache_page', 'cache_path', 'cache_token', 'cache_update', 'cache_variable',
            'cache_views', 'contact', 'ctools_css_cache', 'ctools_object_cache',
            'date_format_locale', 'date_format_type', 'date_formats', 'field_config',
            'field_config_instance', 'field_data_body', 'field_data_comment_body',
            'field_data_field_image', 'field_data_field_portfolio_category',
            'field_data_field_tags', 'field_data_field_video_url', 'field_data_field_website',
            'field_data_field_weight', 'field_revision_body', 'field_revision_comment_body',
            'field_revision_field_image', 'field_revision_field_portfolio_category',
            'field_revision_field_tags', 'field_revision_field_video_url',
            'field_revision_field_website', 'field_revision_field_weight',
            'file_managed', 'file_usage', 'filter', 'filter_format', 'flood',
            'history', 'i18n_block_language', 'i18n_string', 'i18n_translation_set',
            'image_effects', 'image_styles', 'languages', 'locales_source',
            'locales_target', 'menu_custom', 'menu_links', 'menu_router',
            'node', 'node_access', 'node_comment_statistics', 'node_revision',
            'node_type', 'page_manager_handlers', 'page_manager_pages',
            'page_manager_weights', 'panels_display', 'panels_layout', 'panels_pane',
            'panels_renderer_pipeline', 'queue', 'rdf_mapping', 'registry',
            'registry_file', 'role', 'role_permission', 'search_dataset',
            'search_index', 'search_node_links', 'search_total', 'semaphore',
            'sequences', 'sessions', 'shortcut_dataset', 'shortcut_set',
            'shortcut_set_users', 'system', 'taxonomy_index', 'taxonomy_term_data',
            'taxonomy_term_hierarchy', 'taxonomy_vocabulary', 'url_alias',
            'users', 'users_roles', 'variable', 'variable_store', 'vef_video_styles',
            'views_display', 'views_view', 'watchdog', 'wysiwyg', 'wysiwyg_user');

        // Get all of the tables
        $dbname_tables = array();

        // Check table names using known prefix
        if ($this->pdo && $dbname && $dbname !== '*') {
            $table_names = array_merge($wordpress_tables, $drupal_tables);
            foreach ($table_names as $name) {
                $table_name = $dbname . '.' . $dbprefix . $name;

                // If there's no error, table is exists:
                if ($this->pdo->query('SELECT 1 FROM ' . $table_name . ' LIMIT 0')) {
                    $dbname_tables[] = $table_name;
                }
            }

            $this->logger->debugMessage($this->pdo->getErrorMessage());
        }

        return $dbname_tables;
    }

    /**
     * Returns the complete tables list in database.
     * @param string $dbname
     * @return array
     */
    function databaseShowTables($dbname = '*')
    {
        // Get list of tables
        return $this->pdo ? $this->pdo->showTables($dbname) : array();
    }

    /**
     * Fetches the contents of a specific database table.
     * @param string $table_name
     * @param int $table_row_offset
     * @param int $table_row_limit
     * @return string
     */
    function fetchDatabaseTableRows($table_name = '', $table_row_offset = 0, $table_row_limit = 0)
    {
        // Unquoted table name can only contain letters, digits 0-9, dollar, underscore and extended Unicode characters:
        $table_sanitized = preg_replace('~[^a-z0-9\$_\x0080-\xffff\. -]+~siu', '', $table_name);

        $row_limit = $table_row_limit > 0 ? (int) $table_row_limit : 0;
        $row_offset = $table_row_offset > 0 ? (int) $table_row_offset : 0;

        // Get rows from a table (LIMIT and OFFSET are optional)
        $result = $this->pdo->query('SELECT * FROM ' . $table_sanitized
            . ($row_limit > 0 ? ' LIMIT ' . $row_limit : '')
            . ($row_offset > 0 ? ' OFFSET ' . $row_offset : '')
        );

        // Is enough memory?
        $is_enough_memory = true;

        // Collect the database rows data
        $rows_content = $rows_size = $rows_time = array();
        while ($row = $this->pdo->fetch($result)) {

            // Filter row's fields
            $strings = array();
            $table_row_size = 0;
            $table_row_mtime = 0;
            foreach ($row as $field) {
                $table_row_size += strlen($field);

                // Skip empty, non numeric fields and MySQL timestamps
                if (!$field || is_numeric($field)) {
                    continue;
                }

                // Skip MySQL timestamps
                if (!preg_match("/^\d{4}[\/-]\d{2}[\/-]\d{2} \d{2}:\d{2}:\d{2}$/", $field)) {
                    $strings[] = preg_replace("/\n/", "\\n", $field);
                } else {
                    $table_row_mtime = max($table_row_mtime, strtotime($field));
                }
            }

            // Join filtered row content
            $rows_content[] = !empty($strings) ? '' . implode(', ', $strings) . '' : '';
            $rows_size[] = $table_row_size;
            $rows_time[] = $table_row_mtime;

            // Check memory available
            if ($this->benchmark->getMemoryAvailable() <= State::cnf('MAX_SIZE_TO_SCAN_BYTES') * 2) {
                $is_enough_memory = false;
                break;
            }
        }

        // Clean up
        unset($result);

        return array(
            'is_enough_memory'	 => $is_enough_memory,
            'row_limit'			 => $row_limit,
            'row_offset'		 => $row_offset,
            'rows_content'		 => $rows_content,
            'rows_size'			 => $rows_size,
            'rows_time'			 => $rows_time
        );
    }

    /**
     * Scans database content using a php script.
     * @param array $tables
     * @param int $list_offset      Current offset in the array of tables.
     * @param int $table_row_limit  An optimal row LIMIT value is 1000.
     * @return int
     */
    function scanDatabase($tables = array(), $list_offset = 0, $table_row_limit = 1000)
    {
        $this->logger->debugMessage('scanDatabase(' . $list_offset . ')');

        // Scan timeout (1.5 seconds by default), subtract 2%
        $scan_timeout = /* $this->config->scan_timeout * */ 1.5 * .98;

        // Start the timer
        $timer = new \App\Library\CwisTimer();
        $timer->start();

        // Cycle through tables, start/continue from $list_offset
        $max_offset = count($tables);
        for ($i = $list_offset; $i < $max_offset; $i++) {
            if ($i % 10 === 0) {
                $this->benchmark->virtualLoadBalancing();
            }

            // Check memory available
            if ($this->benchmark->getMemoryAvailable() <= State::cnf('MAX_SIZE_TO_SCAN_BYTES') * 2) {
                $this->queue->addMessage(State::msg('_CWIS_MESSAGE_NOT_ENOUGH_MEMORY_AVAILABLE'));
                $this->queue->tables['completed'] = 1;
                $this->queue->tables['size'] = -1;
                return $i + 1; // break
            }

            // Get a table name
            $table_name = $tables[$i];

            // Prepare vars
            $is_enough_memory = true;
            $row_offset = $row_limit = 0;
            $rows_content = $rows_size = $rows_time = array();

            // Start/continue scan (from the last offset if the LIMIT was set)
            $table_row_offset = $table_row_limit > 0 ? (int) $this->queue->tables['offset'] : 0;
            while ($table_row_offset < 2147483647) {

                // Fetch contents of $table_row_limit rows from a table
                extract($this->fetchDatabaseTableRows($table_name, $table_row_offset, $table_row_limit));

                // Database table name for reports
                $pdo_table_name = 'PDO ' . $this->pdo->getDriver() . ':' . $table_name;

                // Count all scanned rows
                $rows_count = count($rows_content);
                if ($rows_count > 0) {
                    $this->queue->tables['rows'] += $rows_count;

                    // Table content buffered (fill till row offset)
                    $pdo_table_buffer = str_repeat(PHP_EOL, $row_offset);
                    foreach ($rows_content as $row_index => $row_content) {
                        $this->queue->tables['size'] += $rows_size[$row_index];

                        // Check the buffer content on last row reached or on buffer oversize
                        $pdo_table_buffer .= $row_content . PHP_EOL; // limit by chunk or max size
                        if (($row_index % ($rows_count > 1 ? $rows_count - 1 : 999) === 0) ||
                            $row_index >= $rows_count - 1 || strlen($pdo_table_buffer) >= State::cnf('MAX_SIZE_TO_SCAN_BYTES') / 2) {
                            $this->benchmark->virtualLoadBalancing();

                            // Row content stat
                            $row_content_stat = array(
                                'mode'	 => 0444,
                                'size'	 => $rows_size[$row_index],
                                'type'	 => 'pdo',
                                'ctime'	 => $rows_time[$row_index],
                                'mtime'	 => $rows_time[$row_index]
                            );

                            // Calculate real row offset
                            $effective_row_offset = $row_offset + $row_index + 1;

                            // Generate negative index
                            $pdo_table_index = -$effective_row_offset; //-$this->getResultCount() - 1;
                            $this->checkFileContent($pdo_table_name . ':' . $effective_row_offset, $pdo_table_index, $pdo_table_buffer,
                                $row_content_stat);

                            // Fill the buffer with empty lines
                            $pdo_table_buffer = str_repeat(PHP_EOL, $effective_row_offset);
                        }

                        // Clean up memory
                        unset($rows_content[$row_index], $rows_size[$row_index], $rows_time[$row_index]);
                    }
                }

                // Was the row LIMIT set?
                if ($table_row_limit > 0) {
                    // Exit if table is empty
                    if ($rows_count === 0) {
                        break;
                    }

                    // Check if memory is enough and the scan is completed
                    if ($is_enough_memory && $rows_count < $row_limit) {
                        break;
                    }

                    // Move to the next row offset
                    $table_row_offset += $rows_count;

                    // Ckeck for the scan timeout (1 sec by default)
                    if ($scan_timeout > 0 && $timer->isTimeUp($scan_timeout)) {
                        $this->queue->tables['offset'] = $table_row_offset;
                        return $i; // save the current offset and exit
                    }
                } else {
                    break; // exit the loop
                }
            }

            // Reset offset (ie table scan is completed)
            $this->queue->tables['offset'] = 0;

            // Ckeck the timer for timeout (1 sec by default)
            if ($scan_timeout > 0 && $timer->isTimeUp($scan_timeout)) {
                return $i + 1; // exit on timeout
            }
        }

        return $max_offset;
    }

    /**
     * Scans file by absolute path to filename.
     * @param string $file_name
     * @param int $file_index
     * @return void
     */
    function scanFile($file_name = '', $file_index = 0)
    {
        // Skip dot only named directories
        if ($file_name === '.' || $file_name === '..') {
            if (State::cwisDebug() >= 3) { // extended logging
                $this->logger->debugMessage('Skip directory "' . $file_name . '"');
            }
            return null;
        }

        // No memory available
        $memory_available = $this->benchmark->getMemoryAvailable();
        if ($memory_available <= State::cnf('MAX_SIZE_TO_SCAN_BYTES') * 2) {
            $this->queue->addMessage(State::msg('_CWIS_MESSAGE_NOT_ENOUGH_MEMORY_AVAILABLE'));
            return null;
        }

        // Skip deleted directories and files
        if (!file_exists($file_name)) {
            $this->logger->debugMessage('Skip deleted file "' . $file_name . '"');
            return null;
        }

        // Set (re)scan progress path
        $this->queue->setProgress($file_name);

        // Get filestat, return on error
        $file_stat = $this->cachedFileStat($file_name);
        if (null === $file_stat) {
            return null;
        }

        // File size and type
        $filesize = $file_stat['size'];
        $filetype = $file_stat['type'];

        // Can't continue scan
        if ($memory_available <= $filesize * 2) {
            $this->logger->debugMessage('No memory available, skip "...' . substr($file_name, -21) . '"');
            return null;
        }

        if (State::cwisDebug() >= 2) {
            $this->logger->debugMessage('scanFile("...' . substr($file_name, -21) . '", ' . $file_index . ')');
        }

        // Check ignore list updated "on-the-fly" (since v2.2.5.9)
        $otf_ignored_files = file_get_array(State::resultsPath() . DIRECTORY_SEPARATOR . 'CWIS-IGNORE.dat');
        foreach ($otf_ignored_files as $ignored_file) {
            if (false !== strpos($ignored_file, $file_name . "\t")) {
                $this->queue->scan['files']['scanned'] ++;

                // Skip files caused to compile-time parse errors (PHP7+)
                $error_message = trim(str_replace($file_name, '', $ignored_file));
                $result_entry_data = array('id'		 => $file_index, 'name'		 => $file_name,
                    'fragment'	 => $error_message, 'stat'		 => $file_stat);
                $this->addCheckResultsIndirect('NotRead', $result_entry_data, false, State::cnf('CWIS_MAX_EXTERNAL_LINKS'));
                return;
            }
        }

        // Reset file content
        $this->file_contents_unwrapped = null;

        // Calculate total file size
        $this->queue->scan['size'] += $filesize;

        // Skip directories, detect symlinks to dirs
        if ($file_name && substr($file_name, -1) === DIRECTORY_SEPARATOR) {
            //$g_Structure['n'][$file_index] = $file_name;
            $this->queue->scan['directories']['scanned'] ++;

            // Read the realpath and detect symlinks (works in WIN)
            if (realpath($file_name) . DIRECTORY_SEPARATOR === $file_name) {
                return; // skip regular directory
            }

            // Report symbolic link
            $result_entry_data = array('id' => $file_index, 'name' => $file_name, 'stat' => $file_stat);
            $this->addCheckResultsIndirect('SymLinks', $result_entry_data);
            return;
        }

        // Start the timer
        $timer = new \App\Library\CwisTimer();
        $timer->start();

        // Detect Git objects (v0.6.0+)
        // https://git-scm.com/book/en/v2/Git-Internals-Git-Objects
        if (stripos($file_name, '.git') && preg_match("#\.git[/\\\]objects[/\\\][0-9a-f]{2}[/\\\][0-9a-f]{38}[/\\\]*$#i",
                $file_name)) {
            $this->queue->scan['files']['skipped'] ++;

            // Skip Git files (don't rescan those!)
            // Note: a literal backslash can be matched using just three backslashes '\\\' unless the next character in the pattern is also backslashed, in which case the literal backslash must be matched using four backslashes.
            $result_entry_data = array('id' => $file_index, 'name' => $file_name, 'stat' => $file_stat);
            $this->addCheckResultsIndirect('GitFiles', $result_entry_data, false, State::cnf('CWIS_MAX_EXTERNAL_LINKS'));
        } elseif ($filesize < 0 || (State::cnf('MAX_SIZE_TO_SCAN_BYTES') > 0 && $filesize > State::cnf('MAX_SIZE_TO_SCAN_BYTES'))) {
            $this->queue->scan['files']['skipped'] ++;

            // Skip large files (don't rescan those!)
            $result_entry_data = array('id' => $file_index, 'name' => $file_name, 'stat' => $file_stat);
            $this->addCheckResultsIndirect('BigFiles', $result_entry_data, false, State::cnf('CWIS_MAX_EXTERNAL_LINKS'));
        } else {

            // Use Magic Bytes (MIME) in "Recommended" level
            if ($this->config->scan_level === 2 && $this->benchmark->getMemoryAvailable() > State::cnf('MAX_SIZE_TO_SCAN_BYTES') * 2) {

                // Detect MIME Content-type for a file
                if (defined('FILEINFO_MIME_TYPE') && functions_exists('finfo_file', 'finfo_open')) {
                    // Constant FILEINFO_MIME_TYPE (available since PHP 5 >= 5.3.0)
                    $fhandle = finfo_open(FILEINFO_MIME_TYPE | FILEINFO_CONTINUE);

                    // It is possible that a FALSE value is returned, if there is no magic MIME database file found on the system
                    if (is_resource($fhandle)) {
                        $mime_type = @finfo_file($fhandle, $file_name); // e.g. gives "image/jpeg"
                        finfo_close($fhandle);
                    }
                } elseif (functions_exists('mime_content_type')) {
                    $mime_type = @mime_content_type($file_name);
                } elseif (strtolower(substr(PHP_OS, 0, 3)) !== 'win' && functions_exists('system')) {
                    $mime_type = trim(system('file -bi --mime-type -m /usr/share/misc/magic ' . escapeshellarg($file_name)));
                } else {
                    $mime_type = false;
                }

                // Prepare for check by file extension
                $file_ext = strtolower(pathinfo($file_name, PATHINFO_EXTENSION));

                // FALSE if an error occurred
                if (false !== $mime_type) {
                    // Filter all known non-binary file types
                    $skip_file = ($mime_type !== 'inode/x-empty' &&
                        false === stripos($mime_type, 'html') &&
                        false === stripos($mime_type, 'script') &&
                        false === stripos($mime_type, 'text') &&
                        false === stripos($mime_type, 'xml')
                    );
                } else {
                    // Skip non-executable files
                    $skip_file = !in_array($file_ext, $this->executable_files);
                }

                if ($skip_file) {
                    // Additionally check by file extension (for example, "octet-stream" type)
                    $skip_file = !in_array($file_ext, $this->sensitive_files);
                }

                // Skipping file
                if ($skip_file) {
                    $this->queue->scan['files']['skipped'] ++;

                    // Skip binary files
                    $result_entry_data = array('id'		 => $file_index, 'name'		 => $file_name,
                        'fragment'	 => 'MIME type: ' . $mime_type, 'stat'		 => $file_stat);
                    $this->addCheckResultsIndirect('SkippedDirs', $result_entry_data, false, State::cnf('CWIS_MAX_EXTERNAL_LINKS'));
                    return null;
                }
            }

            $this->queue->scan['files']['scanned'] ++;

            // Scan file contents
            if ($filetype === 'file') {
                // Ignore itself
                if (0 === strpos($file_name, State::workPath())) {
                    return;
                }

                // Unreadable file check
                $file_contents = @file_get_contents($file_name);

                // Ignore itself (fixed in 3.1.3)
                if (false !== strpos($file_contents, substr(State::cnf('CWIS_SIGNATURE'), 0, 27))) {
                    return;
                }
            }
            // Symlinks
            elseif ($filetype === "link") {
                $this->file_contents_unwrapped = $this->whitelist->fileContentUnwrapped($file_name);
                $result_entry_data = array('id' => $file_index, 'name' => $file_name, 'stat' => $file_stat);
                $this->addCheckResultsIndirect('SymLinks', $result_entry_data);
                return;
            }
            // Skip directories
            elseif ($filetype === "dir") {
                return;
            }
            // Unix executables (file type check)
            else {
                $this->file_contents_unwrapped = $this->whitelist->fileContentUnwrapped($file_name);
                $result_entry_data = array('id' => $file_index, 'name' => $file_name, 'stat' => $file_stat);
                $this->addCheckResultsIndirect('UnixExec', $result_entry_data);
                return;
            }

            // Tests/Simulations
            if (State::cwisDebug() > 0) {
                if (false !== strpos($file_name, 'artificial' . DIRECTORY_SEPARATOR . '.unreadable')) {
                    $file_contents = null;
                }
                if (false !== strpos($file_name, 'artificial' . DIRECTORY_SEPARATOR . '.symlink')) {
                    $result_entry_data = array('id' => $file_index, 'name' => $file_name, 'stat' => $file_stat);
                    $this->addCheckResultsIndirect('SymLinks', $result_entry_data);
                    return;
                }
            }

            // Can't read file contents
            if (!$file_contents && $filesize > 0) {
                $result_entry_data = array('id'		 => $file_index, 'name'		 => $file_name,
                    'fragment'	 => 'File contents are not readable', 'stat'		 => $file_stat);
                $this->addCheckResultsIndirect('NotRead', $result_entry_data);
                return;
            }

            // Unix executables (content check)
            if (false !== strpos($file_contents, chr(127) . 'ELF')) {
                $this->file_contents_unwrapped = $this->whitelist->fileContentUnwrapped($file_name);
                $result_entry_data = array('id' => $file_index, 'name' => $file_name, 'stat' => $file_stat);
                $this->addCheckResultsIndirect('UnixExec', $result_entry_data);
                return;
            }

            // Get file content unwrapped
            $this->file_contents_unwrapped = $this->whitelist->fileContentUnwrapped($file_name);

            // Detect unicode
            $utf_encoding = detect_utf_encoding($file_contents);
            if ($utf_encoding) {

                // Can't convert to UTF-8
                if (!functions_exists('iconv')) {
                    $result_entry_data = array('id'		 => $file_index, 'name'		 => $file_name,
                        'fragment'	 => 'Cannot convert encoding to UTF-8', 'stat'		 => $file_stat);
                    $this->addCheckResultsIndirect('NotRead', $result_entry_data);
                    return;
                }

                // Convert to UTF-8 using iconv()
                $this->whitelist->fileContentUtf8Encoded($this->file_contents_unwrapped, $utf_encoding);
            }

            // Check file contents for threats "as is" (obfuscated)
            if (!$this->checkFileContent($file_name, $file_index, $file_contents, $file_stat)) {

                // Run only in Professional level
                if ($this->config->scan_level >= 3) {
                    if (null === $this->file_contents_unwrapped) {
                        $this->file_contents_unwrapped = $this->whitelist->fileContentUnwrapped($file_name);

                        // Convert to UTF-8 using iconv()
                        $this->whitelist->fileContentUtf8Encoded($this->file_contents_unwrapped);
                    }

                    // Obfuscate unwrapped contents and check for threats
                    $file_contents_unwrapped_obfuscated = $this->utilities->unwrapObfuscated($this->file_contents_unwrapped);
                    $this->checkFileContent($file_name, $file_index, $file_contents_unwrapped_obfuscated, $file_stat);
                }

                // Check for potential PHP code vulnerabilities
                if (/*$this->config->scan_level >= 2 && */$this->config->sec_vuln) {
                    $this->checkFileCodeVulner($file_name, $file_index, $file_contents, $file_stat);
                }
            }

            unset($file_contents, $file_contents_unwrapped_obfuscated);
        }

        // Reduce system load
        if (isset($this->config->scan_delay) && $this->config->scan_delay > 0) {

            // Checking for scan timeout, minimum is 10 / 100 = 0.1 sec
            $scan_timeout = sqrt(100 + $this->benchmark->cpuSpeedTest()) / 100;
            if ($timer->isTimeUp($scan_timeout)) {
                $this->benchmark->cpuThrottle($this->config->scan_delay * 1000);
                $this->logger->debugMessage('Reduce system load (scan took ' . round($scan_timeout, 3) . '+ sec, pause for ' . $this->config->scan_delay . ' ms)');
            }
        }
    }

}
