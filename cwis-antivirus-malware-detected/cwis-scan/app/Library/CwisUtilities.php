<?php

namespace App\Library;

use App\State;

class CwisUtilities
{

    var $scan_path = '';

    /**
     * Creates results directory.
     */
    function createResultsDirectory()
    {
        $dirsCreator = new CwisDirsCreator();
        if (!$dirsCreator->createResultsDir()) {
            header('HTTP/1.0 500 Internal Server Error');
            die($dirsCreator->getLastError());
        }
    }

    /**
     * Builds absolute path to files, used for logs with DEBUG and SCANLOG,
     * and for scan results with PRESCAN, PROGRESS, QUEUE, RESCAN, SHARED.
     * @param string $basename
     * @param string $extension
     * @return string
     */
    function defineFilePath($basename = '', $extension = '.dat')
    {
        // Create results directories
        $dirsCreator = new CwisDirsCreator();
        $dirsCreator->setFilePathHash($this->scan_path);

        // Create scan results subdirectory (using path's MD5 hash)
        if (!$dirsCreator->createResultsSubdir()) {
            header('HTTP/1.0 500 Internal Server Error');
            die($dirsCreator->getLastError());
        }

        // Return absolute path to the file
        return $path_to_file = $dirsCreator->getResultsFilePath($basename, $extension);
    }

    /**
     * Checks if filename is PDO record.
     * @param string $file_name
     * @return string
     */
    function filenameIsPdoRecord($file_name = '')
    {
        return is_string($file_name) && substr($file_name, 0, 4) === 'PDO ';
    }

    /**
     * Expands (inflates) filename or array of filenames.
     * @param string|array $filename
     * @param string $replacement
     * @return string
     */
    function filenameExpand($filename = '', $replacement = '>')
    {
        if (($base_path = State::scanPath() ?? State::rootPath())) {
            return str_replace($replacement, $base_path, $filename);
        }

        return $filename;
    }

    /**
     * String sanitizer for the filename (basename + extension).
     * @param string $filename
     * @return type
     */
    function filenameSanitize($filename = '')
    {
        return preg_replace("#[^\pL\w_,;~\.\-\=\'\!\@\#\$\%\^\&\(\)\[\]\{\}]+#su", '', $filename);
    }

    /**
     * Expands (inflates) filename and returns SHA1 hash of a file.
     * @param string $file_name_packed
     * @param string $replacement
     * @return string
     */
    function filenameSha1($file_name_packed = '', $replacement = '>')
    {
        // sha1_file (PHP 4 >= 4.3.0)
        if (State::phpVersion() >= 40300) {
            $filename = $this->filenameExpand($file_name_packed, $replacement);
            if (is_file($filename) && is_readable($filename) &&
                (State::cnf('MAX_SIZE_TO_SCAN_BYTES') <= 0 || filesize($filename) <= State::cnf('MAX_SIZE_TO_SCAN_BYTES'))) {
                return @sha1_file($filename);
            }
        }

        return null;
    }

    /**
     * Shortens filename for display in UI.
     * @param string $filename
     * @param int $limit
     * @return string
     */
    function filenameShorten($filename = '', $limit = 50, $ellipsis = '...')
    {
        // Limit path length
        $filename_shorten = strlen($filename) > $limit ?
            substr($filename, 0, $limit >> 1) . $ellipsis . substr($filename, 3 - $limit >> 1) : $filename;

        // Sanitize characters using utf8_sanitize
        return utf8_sanitize($filename_shorten);
    }

    /**
     * Shrinks (deflates) filename or array of filenames.
     * @param string|array $filename
     * @param string $replacement
     * @return string
     */
    function filenameShrink($filename = '', $replacement = '>')
    {
        if (($base_path =  State::scanPath() ?? State::rootPath())) {
            return str_replace($base_path, $replacement, $filename);
        }

        return $filename;
    }

    /**
     * Sets scan path.
     * @param string $scan_path
     * @return string
     */
    function setScanPath($scan_path = '')
    {
        $this->scan_path = $scan_path;
    }

    // ---

    /**
     * Returns realpath only for relative paths (realpath returns FALSE on error).
     * @param string $scan_path
     * @return bool|string
     */
    function getRealScanPath($scan_path = '')
    {
        if (!strlen($scan_path) || $scan_path === '.' || $scan_path === '..') {
            return false;
        } else //ignore an absolute path and resolve relative
            if ($scan_path[0] !== '/' && $scan_path[1] !== ':') {
                $scan_path = realpath( State::scanPath() . DIRECTORY_SEPARATOR . $scan_path);
                if (false === $scan_path && false === ($scan_path = realpath($scan_path))) {
                    return false;
                }
            }

        return $scan_path;
    }

    /**
     * Gets an array of unique non-empty scan paths (eg start points).
     * @return array
     */
    function splitScanPath($scan_path = '')
    {
        // Split scan path and trim values
        $scan_paths = array_map('trim', explode(',', $scan_path));

        // Remove invalid and empty paths
        foreach ($scan_paths as $i => $scan_path) {
            if (false === $this->getRealScanPath($scan_path)) {
                unset($scan_paths[$i]);
            }
        }

        // Empty arrays support
        return !empty($scan_paths) ?
            array_keys(array_flip($scan_paths)) : array();
    }

    /**
     * Reads database settings from a file or system defaults and returns as an array.
     * @param string $base_dir  Base directory to start from
     * @param string $settings  Predefined database settings
     * @return array
     */
    function getDatabaseSettingsFromFile($base_dir = '', $settings = array())
    {
        // Override with settings from the root file
        if (defined('CWIS_DB_TYPE')) {
            $settings['type'] = CWIS_DB_TYPE;
        }
        if (defined('CWIS_DB_HOST')) {
            $settings['host'] = CWIS_DB_HOST;
        }
        if (defined('CWIS_DB_USER')) {
            $settings['user'] = CWIS_DB_USER;
        }
        if (defined('CWIS_DB_PASS')) {
            $settings['pass'] = CWIS_DB_PASS;
        }
        if (defined('CWIS_DB_NAME')) {
            $settings['name'] = CWIS_DB_NAME;
        }

        // Is auto parsing enabled?
        if ($settings['type'] !== 'auto') {
            return $settings;
        }

        // Known systems
        $systems = array(
            'Wordpress'	 => array(
                'file'	 => $base_dir . DIRECTORY_SEPARATOR . 'wp-config.php',
                'match'	 => array(
                    '~define\s*\(\s*["\'](\w+)["\'],\s*["\'](.*?)["\']\s*\)~si',
                    '~\$(\w+)\s*=\s*["\'](.*?)["\']~si'
                ),
            ),
            'Joomla!'	 => array(
                'file'	 => $base_dir . DIRECTORY_SEPARATOR . 'configuration.php',
                'match'	 => '~(?:public|var)\s*\$(\w+)\s*=\s*["\'](.*?)["\']~si',
            ),
            'Magento1'	 => array(
                'file'	 => $base_dir . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR . 'etc' . DIRECTORY_SEPARATOR . 'local.xml',
                'match'	 => '~<(\w+)><!\[CDATA\[(.*?)\]\]><\/\1>~si',
            ),
            'Magento'	 => array(
                'file'	 => $base_dir . DIRECTORY_SEPARATOR . 'app' . DIRECTORY_SEPARATOR . 'etc' . DIRECTORY_SEPARATOR . 'env.php',
                'match'	 => '~["\'](\w+)["\']\s*=>\s*["\'](.*?)["\']~si',
            ),
            'MODX'		 => array(
                'file'	 => $base_dir . DIRECTORY_SEPARATOR . 'core' . DIRECTORY_SEPARATOR . 'config' . DIRECTORY_SEPARATOR . 'config.inc.php',
                'match'	 => array(
                    '~\$(\w+)\s*=\s*["\'](.*?)["\']~si'
                ),
            ),
        );

        // Get database settings
        foreach ($systems as $system) {
            $filename = $system['file'];
            $regexps = $system['match'];
            if (!is_array($regexps)) {
                $regexps = array($regexps);
            }

            // Check setting filename
            if (!is_file($filename)) {
                continue;
            }

            $matches = array();
            $content = file_get_array($filename);

            // Loop through the file contents
            foreach ($content as $line) {
                foreach ($regexps as $regexp) {
                    if (!preg_match($regexp, $line, $matches)) {
                        continue;
                    }

                    // Parse values
                    $name = strtoupper($matches[1]);
                    $value = $matches[2];
                    switch ($name) {
                        case 'DATABASE_TYPE': // MODX
                        case 'DBTYPE': // Joomla!
                            $settings['type'] = $value;
                            break;

                        case 'DATABASE_SERVER': // MODX
                        case 'DB_HOST': // WP
                        case 'HOST': // Joomla!
                            $settings['host'] = $value;
                            break;

                        case 'DATABASE_USER': // MODX
                        case 'DB_USER': // WP
                        case 'USER': // Joomla!
                            $settings['user'] = $value;
                            break;

                        case 'DATABASE_PASSWORD': // MODX
                        case 'DB_PASSWORD': // WP
                        case 'PASSWORD': // Joomla!
                            $settings['pass'] = $value;
                            break;

                        case 'DATABASE_NAME': // MODX
                        case 'DB_NAME': // WP
                        case 'DB': // Joomla!
                            $settings['name'] = $value;
                            break;

                        case 'TABLE_PREFIX': // WP
                        case 'DBPREFIX': // Joomla!
                            $settings['prefix'] = $value;
                            break;
                    }
                }
            }
        }

        return $settings;
    }

    /**
     * Formats bytes to human readable.
     * @param integer $bytes
     * @param integer $decimals
     * @return string
     */
    function formatBytes($bytes, $decimals = 0)
    {
        $units = array(
            'Bytes', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB', 'EiB', 'ZiB', 'YiB'
        );

        foreach ($units as $i => $unit) {
            if (abs($bytes) < 1024) {
                return ($i ? number_format($bytes, $decimals) : $bytes) . ' ' . $unit;
            }

            $bytes /= 1024;
        }
    }

    /**
     * Formats a local time/date.
     * @param integer $timestamp
     * @param string $format
     * @return string
     */
    function formatDates($timestamp, $format = 'Y-m-d H:i')
    {
        return date($format, $timestamp);
    }

    /**
     * Formats time to human readable "h:mm:ss".
     * @param integer $time
     * @param integer $decimals
     * @return string
     */
    function formatSeconds($time, $decimals = 0)
    {
        $hours = floor($time / 3600);
        $time -= $hours * 3600;

        $minutes = floor($time / 60);
        $time -= $minutes * 60;

        if ($decimals > 0 && $decimals <= 20) {
            $seconds = number_format($time, intval($decimals, 10));
        } else {
            $seconds = intval(floor($time) % 60, 10);
        }

        return $hours
            . ':' . ($minutes < 10 ? '0' . $minutes : $minutes)
            . ':' . ($seconds < 10 ? '0' . $seconds : $seconds);
    }

    /**
     * Extracts email addresses from the string.
     * @param string $string
     * @return array of strings with emails or false on error
     */
    function getEmails($string = '')
    {
        $matches = array();

        // Regex used in HTML5's type=”email” from W3C, source: http://emailregex.com/
        if (preg_match_all("/[a-z0-9.!#$%&’*+\/=?^_`{|}~-]+@[a-z0-9-]+(?:\.[a-z0-9-]+)*/i", $string, $matches)) {
            return array_keys(array_flip($matches[0]));
        }

        return false;
    }

    /**
     *
     * @param string $base_dir
     * @param int $max_depth
     * @param int $depth
     * @return array
     */
    function recursiveDirectoryScan($base_dir = '', $max_depth = 255, $depth = 0)
    {
        $directories = array();

        if ($base_dir && is_dir($base_dir) && is_readable($base_dir) && ($handle = opendir($base_dir))) {
            $directories[] = $base_dir;

            while (false !== ($entry = readdir($handle))) {
                // Strip out "." and ".."
                if ($entry == '.' || $entry == '..') {
                    continue;
                }

                $filename = $base_dir . DIRECTORY_SEPARATOR . $entry;
                if (is_dir($filename) && $depth < $max_depth) {
                    $directories = array_merge($directories, $this->recursiveDirectoryScan($filename, $max_depth, $depth + 1));
                }
            }
            closedir($handle);
            unset($handle);
        }

        // Optimize using faster analog of array_unique
        return array_keys(array_flip($directories));
    }

    function unwrapObfuscated($file_contents = '')
    {

        $search = array(' ;', ' =', ' ,', ' .', ' (', ' )', ' {', ' }', '; ', '= ',
            ', ', '. ', '( ', '( ', '{ ', '} ', ' !', ' >', ' <', ' _', '_ ', '< ', '> ',
            ' $', ' %', '% ', '# ', ' #', '^ ', ' ^', ' &', '& ', ' ?', '? ');
        $replace = array(';', '=', ',', '.', '(', ')', '{', '}', ';', '=', ',', '.',
            '(', ')', '{', '}', '!', '>', '<', '_', '_', '<', '>', '$', '%', '%',
            '#', '#', '^', '^', '&', '&', '?', '?');

        $file_contents = str_replace('@', '', $file_contents);
        $file_contents = preg_replace('/\s+/', ' ', $file_contents);
        $file_contents = str_replace($search, $replace, $file_contents);

        $file_contents = preg_replace_callback('#\bchr\(\s*([0-9a-fA-FxX]+)\s*\)#', 'quotWrapperFunc', $file_contents);
        $file_contents = preg_replace_callback('#\\\\x([a-fA-F0-9]{1,2})#i', 'escapedHexToHex', $file_contents);
        $file_contents = preg_replace_callback('#\\\\([0-9]{1,3})#i', 'escapedOctDec', $file_contents);

        // Replace string concatenations ('x' . 'y' = 'xy' in PHP and 'x' + 'y' = 'xy' in JS)
        $file_contents = preg_replace('#(\'\s*[.+]+\s*\'|\"\s*[.+]+\s*\")#', '', $file_contents);

        return $file_contents;
    }

}
