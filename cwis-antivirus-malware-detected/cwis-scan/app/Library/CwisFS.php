<?php

namespace App\Library;

use App\State;
use App\Library\CwisManageQuarantine;

class CwisFS {

  public function __construct() {

  }

  public static function format_permisions($perms) {

    switch ($perms & 0xF000) {
        case 0xC000: // socket
            $info = 's';
            break;
        case 0xA000: // symbolic link
            $info = 'l';
            break;
        case 0x8000: // regular
            $info = 'r';
            break;
        case 0x6000: // block special
            $info = 'b';
            break;
        case 0x4000: // directory
            $info = 'd';
            break;
        case 0x2000: // character special
            $info = 'c';
            break;
        case 0x1000: // FIFO pipe
            $info = 'p';
            break;
        default: // unknown
            $info = 'u';
    }

    // Owner
    $info .= (($perms & 0x0100) ? 'r' : '-');
    $info .= (($perms & 0x0080) ? 'w' : '-');
    $info .= (($perms & 0x0040) ?
                (($perms & 0x0800) ? 's' : 'x' ) :
                (($perms & 0x0800) ? 'S' : '-'));

    // Group
    $info .= (($perms & 0x0020) ? 'r' : '-');
    $info .= (($perms & 0x0010) ? 'w' : '-');
    $info .= (($perms & 0x0008) ?
                (($perms & 0x0400) ? 's' : 'x' ) :
                (($perms & 0x0400) ? 'S' : '-'));

    // World
    $info .= (($perms & 0x0004) ? 'r' : '-');
    $info .= (($perms & 0x0002) ? 'w' : '-');
    $info .= (($perms & 0x0001) ?
                (($perms & 0x0200) ? 't' : 'x' ) :
                (($perms & 0x0200) ? 'T' : '-'));

    return $info;

  }

  public static function reset($files, $folders, $zipfile) {

    $zip = new \ZipArchive;
    $quarantine = new CwisManageQuarantine();
    $all_folder_files = [];
    $o = ['untouched' => [], 'replaced' => [], 'added' => [], 'removed' => []];

    echo count($folders);
    if(count($folders)) {
      $base   = State::scanPath() . DIRECTORY_SEPARATOR;
      foreach($folders as $ind => $folder) {
        $source = $base . $folder . '/';
        $dir_files = new \RecursiveIteratorIterator (new \RecursiveDirectoryIterator($source), \RecursiveIteratorIterator::SELF_FIRST);
        foreach ($dir_files as $file) {
           $file = str_replace('\\', '/', $file);
           if( in_array(substr($file, strrpos($file, '/')+1), array('.', '..')) ) {
             continue;
           }
           if(!is_file($file)) {
             continue;
           }
           $all_folder_files[$file] = true;
        }
      }
    }

    //print_r($all_folder_files);

    if ($zip->open($zipfile) === true) {

        for ($i = 0; $i < $zip->numFiles; $i++) {
            $RETVAL = false;
            $filename = $zip->getNameIndex($i);
            $fn = State::scanPath() . DIRECTORY_SEPARATOR . $filename;

            if(isset($all_folder_files[$fn])) {

              $fp = $zip->getStream($filename);
              if($fp) {
                $sig_new = sha1(stream_get_contents($fp));
                $sig_old = sha1_file($fn);
                if($sig_old == $sig_new) {
                  // Do nothing, good file
                  $o['untouched'][] = $filename;

                } else {
                  $res = $quarantine->manageFile('move', $fn);
                  $zip->extractTo(State::scanPath() . DIRECTORY_SEPARATOR, $filename);
                  $o['replaced'][] = $filename;
                }
              }
              unset($all_folder_files[$fn]);

            } else {
              $zip->extractTo(State::scanPath() . DIRECTORY_SEPARATOR, $filename);
              $o['added'][] = $filename;
            }
        }

        foreach($all_folder_files as $fn => $val) {
          $res = $quarantine->manageFile('move', $fn);
          $o['removed'][] = str_replace(State::scanPath() . DIRECTORY_SEPARATOR, '', $fn);
        }
        // close
        $zip->close();
        return $o;

    } else {
      return false;
    }

  }

  public static function archive($files, $folders, $zipfn) {

    if(($files && count($files)) || ($folders && count($folders))) {

      $zipfile = State::scanPath() . DIRECTORY_SEPARATOR . $zipfn;
      $zipArchive = new \ZipArchive;
      if ($zipArchive->open($zipfile, (\ZipArchive::CREATE | \ZipArchive::OVERWRITE)) !== true) {
        die("Failed to create archive\n");
      }

      foreach ($folders as $index => $fn) {

        $base   = State::scanPath() . DIRECTORY_SEPARATOR;
        $source = $base . $fn;

        $dir_files = new \RecursiveIteratorIterator (new \RecursiveDirectoryIterator($source), \RecursiveIteratorIterator::SELF_FIRST);

        foreach ($dir_files as $file) {

             $file = str_replace('\\', '/', $file);

             // Ignore "." and ".." folders
             if( in_array(substr($file, strrpos($file, '/')+1), array('.', '..')) )
                 continue;

             $file = realpath($file);

             if (is_dir($file) === true)
             {
                 $zipArchive->addEmptyDir(str_replace($base, '', $file . '/'));
             }
             else if (is_file($file) === true)
             {
                 $zipArchive->addFromString(str_replace($base, '', $file), file_get_contents($file));
             }

        }

      }
      foreach ($files as $index => $fn) {

        $target = State::scanPath() . DIRECTORY_SEPARATOR . $fn;
        $zipArchive->addFile($target, $fn);
        if ($zipArchive->status != \ZIPARCHIVE::ER_OK) {}

      }

      $zipArchive->close();

    }

  }

}
