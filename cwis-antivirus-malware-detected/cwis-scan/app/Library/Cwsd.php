<?php

namespace App\Library;

use App\Library\Cwis_Defender_Admin;
use App\Library\Cwis_Defender_Settings;
use App\Library\Cwis_Defender_Guarder;
use App\Library\CwisApi;

use App\State;

class Cwsd extends Cwis_Core_Foundation
{

    protected $cwis_defender_admin = null;
    protected $cwis_defender_guarder = null;
    protected $cwis_defender_settings = null;
    protected $cwis_defender_config = null;

  private function map_headers($headers) {
    foreach($headers as $key => $value) {
      switch($value) {
        case 'REQUEST_URI':
          $headers[$key] = $_SERVER[$value];
        break;
        default:
          $headers[$key] = isset($_SERVER[$value]) ? substr($_SERVER[$value], 0, 1024) : '';
        break;
      }
    }
    return $headers;
  }

    private function is_blocked_headers(&$headers, $blocked = false)
    {
        $headers['rule'] = $blocked ? 'BLOCKED' : 'OK';
    }

  private function fix_headers(&$headers) {
      $out = [];
      foreach($headers as $key => $value) {
          $out[] = $key . ': ' . $value;
      }
      $headers = $out;
  }

    /**
     * Define the core functionality of the plugin.
     *
     * Set the plugin name and the plugin version that can be used throughout the plugin.
     * Load the dependencies, define the locale, and set the hooks for the admin area and
     * the public-facing side of the site.
     *
     * @since    1.0.0
     */
    public function __construct($plugin_name, $version, $loader = null)
    {
        parent::__construct($plugin_name, $version, $loader);

        $this->cwis_defender_admin = $this->get_class_instance(Cwis_Defender_Admin::class);

        // Map current class..
        $this->cwis_defender_admin->cwsd = $this;

        $this->cwis_defender_guarder = $this->get_class_instance(Cwis_Defender_Guarder::class);
        $this->cwis_defender_settings = $this->get_class_instance(Cwis_Defender_Settings::class);

        $this->define_plugin_hooks();

    }



    /**
     * Register all of the hooks related to the plugin functionality.
     *
     * @since   1.0.0
     * @access  private
     */
    private function define_plugin_hooks()
    {
        // Backend or frontend?
        if (State::isAdmin()) {
            \add_action('activated_plugin', [$this->cwis_defender_admin, 'reinstall_guarder_protection'], 10, 2);
        }
        // Check if not in backend of WordPress, not doing AJAX or CRON-JOB requests,
        // and not one of the APP (Atom Publishing Protocol), REST or XML-RPC requests.
        elseif (!defined('WP_ADMIN') && !defined('DOING_AJAX') && !defined('DOING_CRON') &&
            !defined('APP_REQUEST') && !defined('REST_REQUEST') && !defined('XMLRPC_REQUEST')) {

              include_once State::scanPath() . '/wp-includes/plugin.php';
              include_once State::scanPath() . '/wp-load.php';
              // Cleanup the HTML output of the blog
              \add_action('init', [$this->cwis_defender_admin, 'wordpress_security_hardening']);

              // Whether the client IP included in the whitelist?
              if (!$this->cwis_defender_guarder->is_client_whitelisted()) {

                // --- ANTISPAM ---
                if ($this->cwis_defender_settings->get('antispam')) {

                    // Add hook for front-end <head></head>
                    \add_action('login_enqueue_scripts', [$this->cwis_defender_admin, 'wordpress_antibot_protection']);
                    \add_action('login_errors', [$this->cwis_defender_admin, 'wordpress_antibot_protection']);
                    \add_action('wp_head', [$this->cwis_defender_admin, 'wordpress_antibot_protection']);

                    // Verifies POST request
                    \add_filter('init', [$this->cwis_defender_admin, 'wordpress_antibot_verify']);
                }

                // --- BFA PROTECTION ---
                if ($this->cwis_defender_settings->get('bruteforce')) {

                    // This hook fires after a user login has failed
                    \add_action('wp_login_failed', [$this->cwis_defender_admin, 'wordpress_antibot_login_failed']);

                    // Displays message on the WordPress Log In page above the form
                    \add_filter('login_message', [$this->cwis_defender_admin, 'wordpress_antibot_login_message']);
                }

              }

        }
    }

    private function run_emerging() {

      $emerging = CwisApi::fetch_emerging();
      if($emerging && count($emerging)) {

        $ip_array = $this->cwis_defender_guarder->get_client_ips();
        $client_ip = reset($ip_array);
        $match = $this->cwis_defender_guarder->match_client_ip($emerging, $client_ip);

        if($match) {

          $res = $this->run_remote_info();
          $res['reason'] = 'Emerging blacklist entry ' . $match;
          $this->cwis_defender_guarder->block_user_access(json_encode($res));
          //$cwis_defender_guarder->block_user_ip($reason);
        }
      }

    }

    private function get_content_length($headers) {
      $len = 0;
      foreach($headers as $index => $value) {
        $len += strlen($index) + strlen($value) + 2;
      }
      return $len;
    }

    public function run_remote_info()
    {
        $headers = $this->attach_basic_headers([]);

        $this->is_blocked_headers($headers, true);

        $this->fix_headers($headers);
        $res = CwisApi::curl_auth($headers, false);
        $res = json_decode($res, true);

        if (!$res || !is_array($res)) {
            return [];
        }

        return $res;
    }

    public static function sort_post_size($in) {
      return is_object($in) ? strlen(json_encode($in)) : strlen($in);
    }

    private function get_post_data() {

      $post_data = [];

      if(isset($_FILES) && $_FILES) {
        $post_data['$_FILES'] = $_FILES;
      }

      if(isset($_POST) && $_POST) {

        if(isset($_SERVER['CONTENT_LENGTH']) && $_SERVER['CONTENT_LENGTH'] < State::cnf('MAX_POST_SIZE')) {
          return $_POST;
        }

        $o_len   = 0;
        $data    = [];
        $p_tot   = count($_POST);
        $inc     = 0;
        $lengths = array_map('App\Library\Cwsd::sort_post_size', $_POST);

        asort($lengths);

        foreach($lengths as $index => $len) {
          $cut     = State::cnf('MAX_POST_SIZE') - $o_len;
          $max_cut = intval($cut / ($p_tot - $inc));
          if($max_cut >= $len) {
            $data[$index] = $_POST[$index];
            $o_len += $len;
          } else {
            $data[$index] = substr(( is_array($_POST[$index]) ? json_encode($_POST[$index]) : $_POST[$index] ), 0, $max_cut);
            $o_len += $max_cut;
          }
          $inc     ++;
        }

        $post_data['$_POST'] = $data;

      } else {
        $raw = file_get_contents('php://input');
        $raw = substr($raw, 0, State::cnf('MAX_POST_SIZE'));
        $post_data['$_POST'] = $raw;
      }

      return $post_data;

    }

    private function attach_root_headers($headers)
    {
        // Set IP
        $ip_array = $this->cwis_defender_guarder->get_client_ips();
        $ip = reset($ip_array);
        $headers['x-original-ip']	= $ip;

        // Set URL
        $https = (isset($_SERVER['REQUEST_SCHEME']) && $_SERVER['REQUEST_SCHEME'] == 'https') ||
            (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on');
        $url   = ($https ? "https://" : "http://") . ( isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : '' );
        $headers['x-original-host'] = $url;

        return $headers;
    }

    private function attach_basic_headers($headers)
    {
        $basic_headers = [
            'x-method'         => 'REQUEST_METHOD',
            'x-original-uri'   => 'REQUEST_URI',
            'x-content-type'   => 'CONTENT_TYPE',
            'x-referer'        => 'HTTP_REFERER',
            'x-user-agent'     => 'HTTP_USER_AGENT',
            'x-content-length' => 'CONTENT_LENGTH'
        ];

        // Map from request
        $headers = $this->map_headers($basic_headers);
        $headers = $this->attach_root_headers($headers);

        return $headers;
    }

    private function run_remote($report_level = 0, $do_block = false)
    {
        $headers   = [];
        $post_data = false;

        switch($report_level) {
            case 1:  // IP ONLY
                $headers = $this->attach_root_headers([]);
            break;
            case 0:  // BASIC HEADERS
                $headers = $this->attach_basic_headers([]);
            break;
            case -1: // ALL
                $headers = $this->attach_basic_headers([]);
                if (isset($_SERVER['REQUEST_METHOD']) && $_SERVER['REQUEST_METHOD'] === 'POST') {
                    $post_data = $this->get_post_data();
                }
            break;
        }

        $this->is_blocked_headers($headers);

        $this->fix_headers($headers);

        //print_r($post_data);
        $res = CwisApi::curl_auth($headers, $post_data);
        // No result
        if (!$res) {
            return;
        }

        try {
            $res = json_decode($res, true);

            $conf_asn     = $this->cwis_defender_settings->get('asn');
            $conf_geo     = $this->cwis_defender_settings->get('geo');
            $conf_geo_inv = $this->cwis_defender_settings->get('geo_not');

            if (isset($res['geo']) && $conf_geo) {
                $listed = in_array($res['geo'], explode(',', $conf_geo));
                if ((!$conf_geo_inv && $listed) || ($conf_geo_inv && !$listed)) {
                    $res['reason'] = 'GEO';
                    $this->cwis_defender_guarder->block_user_access(json_encode($res));
                    //$this->cwis_defender_guarder->block_user_ip($reason);
                }
            }

            if (isset($res['as']) && $conf_asn) {
                $listed = in_array(intval($res['as']). '', explode(',', $conf_asn));
                if ($listed) {
                    $res['reason'] = 'ASN';
                    $this->cwis_defender_guarder->block_user_access(json_encode($res));
                    //$this->cwis_defender_guarder->block_user_ip($reason);
                }
            }

            if ((isset($res['r1']) || isset($res['r2'])) && $do_block) {
                $res['reason'] = 'BLK';
                $this->cwis_defender_guarder->block_user_access(json_encode($res));
                //$this->cwis_defender_guarder->block_user_ip($reason);
            }

        } catch(Exception $e) {}
    }

    public function run_antibot($allowed_bots = '') {

      // Block unwanted traffic by UA
      $this->cwis_defender_guarder->check_user_agent();
      $chk = $this->cwis_defender_guarder->check_user_ip();
      if ($chk) {

        $res = $this->run_remote_info();
        $res['reason'] = 'Copier';

        return $this->cwis_defender_guarder->block_user_access(json_encode($res));
      }

      $URI = isset($_SERVER['REQUEST_URI']) ? $_SERVER['REQUEST_URI'] : null;

      $is_bot = $this->cwis_defender_guarder->is_search_engine_bot();
      if($is_bot) {
        $listed = in_array($is_bot, explode(',', $allowed_bots));
        if(!$listed) {
          $map = State::cnf('CWIS_CRAWLERS_MAP');
          $label = isset($map[$is_bot]) ? $map[$is_bot] : $is_bot;

          $res = $this->run_remote_info();
          $res['reason'] = 'Bots not allowed :: ' . $label;
          $this->cwis_defender_guarder->block_user_access(json_encode($res));
          //$this->cwis_defender_guarder->block_user_ip($reason);
        }
      } else {



        $this->cwis_defender_config = $this->get_class_instance(Cwis_Defender_Config::class);
        if (!$this->cwis_defender_config->is_url_replacement_path($URI)) {

          // Track the page view
          $page_path_tokenized = strtok($URI, '?');
          $this->cwis_defender_guarder->track_pageview($page_path_tokenized);

            if (State::isAdmin()) {
                return $is_bot;
            }

          // Block user on suspicious activity
          $activity = $this->cwis_defender_guarder->check_pageviews_activity();
          if ($activity[15]['factor'] > 3 && $activity[15]['entries'] > 6 &&
              $activity[15]['factor'] * 6 > $activity[15]['entries']) {

              $res = $this->run_remote_info();
              $res['reason'] = 'Copier';

              $this->cwis_defender_guarder->block_user_access(json_encode($res)); //block for 15 min

          } elseif ($activity[60]['factor'] > 3 && $activity[15]['entries'] > 6 &&
              $activity[60]['factor'] * 6 > $activity[60]['total']) {

              $res = $this->run_remote_info();
              $res['reason'] = 'Copier';

              $this->cwis_defender_guarder->block_user_ip(json_encode($res)); //hard block for 1 day

          }
        }

      }
      return $is_bot;

    }

    public function run_defender() {

      $antibot  = $this->cwis_defender_settings->get('antibot');
      $allowbot = $this->cwis_defender_settings->get('bots');
      $remote   = $this->cwis_defender_settings->get('remote');
      $report   = $this->cwis_defender_settings->get('report');
      $lists    = $this->cwis_defender_settings->get('lists');

      // Check whitelisted
      if ($this->cwis_defender_guarder->is_client_whitelisted()) {
        return;
      }

      // Check blacklisted
      if ($this->cwis_defender_guarder->is_client_blacklisted()) {

        $res = $this->run_remote_info();
        $res['reason'] = 'Blacklisted';
        $this->cwis_defender_guarder->log_temp_block('Blacklisted');
        $this->cwis_defender_guarder->block_user_access(json_encode($res));

      }

      // Run Antibot
      if ($antibot) {
        $is_bot = $this->run_antibot($allowbot);
        if($is_bot) {
          return;
        }
      }

      // Emerging
      if($lists == 0 || $lists == -1) {
        $this->run_emerging();
      }

      // Check IP remotely
      if($remote) {
        $this->run_remote($report, $lists == -1);
      }

    }
}
