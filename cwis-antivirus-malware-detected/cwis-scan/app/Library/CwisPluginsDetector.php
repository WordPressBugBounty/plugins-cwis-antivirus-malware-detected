<?php

namespace App\Library;

use App\State;

class CwisPluginsDetector
{
    use Definitions;

    //
    // List of known plugins directories
    var $cms_plugins = array(
        'Wordpress'	 => array(
            'name'	 => 'Wordpress',
            'paths'	 => array(
                '/wp-content/plugins',
                '/wp-content/themes'
            ),
            'regex'	 => array(
                'readme.txt' => array(
                    'PACKAGE'	 => '^===\s*(.+?)\s*===\s*$',
                    'VERSION'	 => '^\s*(?:Version|Stable tag):\s+(.+?)\s*$',
                    'CHNGLOG'	 => '^\==\s*Change\s*log\s*==[^=]+=\s*v?([\d\.]+)[^=]*=\s*$',
                ),
                '*.php'		 => array(
                    'PACKAGE'	 => '^\s*(?:\*\s*)?Plugin name:\s+(.+?)$',
                    'VERSION'	 => '^\s*(?:\*\s*)?Version:\s+(.+?)$',
                )
            )
        ),
        'Joomla'	 => array(
            'name'	 => 'Joomla!',
            'paths'	 => array(
                '/administrator/components',
                '/administrator/modules',
                '/administrator/templates',
                '/components',
                '/modules',
                '/plugins/content',
                '/plugins/system',
                '/templates'
            ),
            'regex'	 => array(
                '*.php'	 => array(
                    'PACKAGE'	 => '^\s*(?:\*\s*)?\@package\s+(.+?)$',
                    'VERSION'	 => '^\s*(?:\*\s*)?\@version\s+(.+?)$',
                ),
                '*.xml'	 => array(
                    'PACKAGE'	 => '\<name\>([^\<]+)\<\/name\>',
                    'VERSION'	 => '\<version\>([^\<]+)\<\/version\>',
                )
            )
        ),
    );
    //
    // Detected plugins
    var $plugins = array();
    //
    // Private strings
    var $plugin_path, $plugin_name, $plugin_version;
    //
    // Enable deep detection methods?
    var $deep_plugin_scan = false;

    /**
     * Use this method as a class constructor.
     * @param mixed $config
     */
    function construct($config = null)
    {
        // Instantiate the core classes
        $this->logger = new CwisLogger();
        $this->utilities = new CwisUtilities();

        // Use configuration options
        if (gettype($config) === 'object') {

            // Improved (but slower) detection methods
            $this->deep_plugin_scan = $config->scan_all_files;
            $this->logger->setScanPath($config->getScanPath());
        }
    }

    /**
     * Checks the directories list.
     * @param array $dir_list
     */
    function checkDirectories($dir_list = array())
    {
        $this->logger->debugMessage('$plugins->checkDirectories()');
        foreach ($dir_list as $dir_packed) {
            $dir = $this->utilities->filenameExpand($dir_packed);
            $this->checkDirectory($dir);
        }
    }

    /**
     * Checks the directory.
     * @param array $dir
     */
    function checkDirectory($dir = '')
    {
        // Pack the path
        if (State::cwisDebug() >= 2) {
            $this->logger->debugMessage('CwisPluginsDetector("' . $this->utilities->filenameShrink($dir) . '")');
        }

        // Cycle through CMS plugins list
        foreach ($this->cms_plugins as $cms_id => $cms_data) {
            if (is_array($cms_data) && isset($cms_data['paths'])) {
                $plugin_paths = is_array($cms_data['paths']) ? $cms_data['paths'] : array($cms_data['paths']);
                $plugin_regex = isset($cms_data['regex']) ? $cms_data['regex'] : array();

                // Check for plugins in directory "plugin_path"
                foreach ($plugin_paths as $plugin_path) {

                    // Slash-normalised path to plugins "root" directory
                    $root_directory_normalized = $dir . normalize_path($plugin_path);
                    if (!is_dir($root_directory_normalized)) {
                        continue;
                    }

                    // Check if "root" directory contains plugins
                    $plugin_dirs = $this->getDirList($root_directory_normalized);
                    foreach ($plugin_dirs as $plugin_dir) {
                        if ($this->checkPlugin($plugin_dir, $plugin_regex)) {
                            $cms_name = isset($cms_data['name']) ? $cms_data['name'] : $cms_id;
                            $this->addPlugin($cms_name);
                        }
                    }
                }
            }
        }
    }

    function getDirList($target = '')
    {
        $directories = array();
        if ($target && is_dir($target) && is_readable($target)) {
            $directories = array_merge(array($target), scan_dir($target, $exclude = array('.', '..', 'index.php')));
        }

        return $directories; //an original code: return $this->utilities->recursiveDirectoryScan($target, 1);
    }

    function getPlugins()
    {
        return $this->plugins;
    }

    // --- PRIVATE METHODS ---

    function addPlugin($cms_name = '')
    {
        $this->plugins[$this->plugin_path] = $cms_name . "\t" . $this->plugin_name . "\t" . $this->plugin_version;
    }

    function checkPlugin($dir, $params = array())
    {
        // Validate params and check the path first
        if (!is_array($params) || !file_exists($dir)) {
            return false;
        }

        // Reset plugin params
        $this->plugin_path = '';
        $this->plugin_name = '';
        $this->plugin_version = '';

        // Scan plugin directory on deep scan enabled, filter files
        //$plugin_files = $this->deep_plugin_scan ? array_filter(scan_dir($dir), 'is_file') : array();
        $scdir=scan_dir($dir);

        if($this->deep_plugin_scan) {
            if(false !== $scdir) {
                $plugin_files = array_filter($scdir, 'is_file');
            } else {
                $plugin_files = null;
            }
        } else {
            $plugin_files =  array();
        }
        // Process additional parameters
        foreach ($params as $file_rule => $regexps) {
            // The "*" in file rule is always replaced with parent dir basename
            $file_name = str_replace('*', basename($dir), $file_rule);

            // Check directory
            if (!is_dir($dir)) {
                // Support for files (since v2.3.0.6)
                $file_path = $dir;
            } elseif ($file_name) {
                // Path to plugin root file
                $file_path = $dir . DIRECTORY_SEPARATOR . $file_name;
                if (!is_file($file_path)) { // support for J!components
                    $file_path = $dir . DIRECTORY_SEPARATOR . substr($file_name, 4); // remove prefix com_
                }
            }

            // Collect file paths
            if (!empty($plugin_files)) {
                // Convert file mask to the regex pattern
                $file_rule_regex = preg_quote(DIRECTORY_SEPARATOR . $file_rule, '#');
                $file_rule_pattern = '#' . str_replace('\*', '.*?', $file_rule_regex) . '$#i';

                $file_paths = array();
                foreach ($plugin_files as $plugin_file) {
                    if (preg_match($file_rule_pattern, $plugin_file)) {
                        $file_paths[] = $plugin_file;
                    }
                }
            } else {
                $file_paths = array($file_path);
            }

            // Check plugin files content
            foreach ($file_paths as $file_path) {
                $result = $this->checkPluginFileContent($file_path, $regexps);
                if ($result) {

                    // Skip Joomla's components
                    if ($result['plugin_name'] === 'Joomla.Administrator' ||
                        $result['plugin_name'] === 'Joomla.Plugin' ||
                        $result['plugin_name'] === 'Joomla.Site') {
                        $result['plugin_name'] = '';
                    }

                    // Fix Wordpress plugin name placeholder
                    if ($result['plugin_name'] === 'Plugin Name') {
                        $result['plugin_name'] = ucwords(str_replace(array('-', '+', '_'), ' ', basename($dir)));

                        // Drop everything that comes after the dot
                        if (false !== ($dotpos = strpos($result['plugin_name'], '.'))) {
                            $result['plugin_name'] = substr($result['plugin_name'], 0, $dotpos);
                        }
                    }
                }

                // Set a plugin path if empty (one-time)
                if (!$this->plugin_path && $result && $result['plugin_path']) {
                    $this->plugin_path = $result['plugin_path'];
                }

                // Set a plugin name if it is empty (one-time)
                if (!$this->plugin_name && $result && $result['plugin_name']) {
                    $this->plugin_name = $result['plugin_name'];
                }

                // Stop if plugin name and version were defined
                if ($this->plugin_path && $this->plugin_name && $result && $result['plugin_version']) {
                    $this->plugin_version = $result['plugin_version'];
                    break;
                }
            }
        }

        // Accept a valid plugin path and name
        if ($this->plugin_path && $this->plugin_name) {
            return true;
        }

        return false;
    }

    function checkPluginFileContent($file_path = '', $regexps = array())
    {
        if ($file_path && !empty($regexps) && is_file($file_path) && is_readable($file_path)) {

            // Replace Windows-format EOL with standard "\n"
            $content = file_get_contents_safe($file_path);

            // Convert to standard format
            if (!is_array($regexps)) {
                $regexps = array(
                    'PACKAGE'	 => $regexps,
                    'VERSION'	 => $regexps
                );
            }

            // Check regExps
            $matches = $scheme = array();
            foreach ($regexps as $version_type => $regexp) {
                if (preg_match('#' . $regexp . '#smi', $content, $matches)) {
                    $scheme[$version_type] = $matches[1];
                }

                if (State::cwisDebug() >= 2) {
                    $this->logger->debugMessage('checkPlugin["' . basename($file_path) . '", ' . $version_type . ' = ' .
                        (!empty($matches) ? $matches[1] : '"#' . $regexp . '#smi"') . ']');
                }
            }

            // No matches, exit...
            if (empty($scheme)) {
                return false;
            }

            // Temporal results
            $plugin_name = $plugin_version = '';

            // Read package name
            if (isset($scheme['PACKAGE'])) {
                $plugin_name = trim($scheme['PACKAGE']);
            }

            // Read package version
            if (isset($scheme['VERSION'])) {
                // Check plugin version number for validity
                $plugin_version = trim($scheme['VERSION']);
                if (version_compare($plugin_version, '0.0.0') <= 0) {
                    $plugin_version = '';
                }
            }

            // Read version from the changelog
            if (isset($scheme['CHNGLOG']) && !$plugin_version) {
                $plugin_version = trim($scheme['CHNGLOG']);
            }

            // Set plugin path, name and version number
            if ($plugin_name) {
                return array(
                    'plugin_path'	 => $this->utilities->filenameShrink($file_path),
                    'plugin_name'	 => $plugin_name,
                    'plugin_version' => $plugin_version
                );
            }
        }

        return false;
    }

}
