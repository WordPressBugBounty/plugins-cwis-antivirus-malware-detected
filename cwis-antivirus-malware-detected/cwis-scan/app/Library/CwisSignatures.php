<?php

namespace App\Library;

use App\State;

class CwisSignatures
{

    var $g_WebShells, $gX_WebShells,
        $gXXX_DBShe, $gXXX_FlexDBShe,
        $g_DBShe, $gX_DBShe,
        $g_FlexDBShe, $gX_FlexDBShe, $gXX_FlexDBShe,
        $g_ExceptFlex,
        $g_AdwareSig, $gX_AdwareSig,
        $g_PhishSig,
        $g_JSVirSig, $gX_JSVirSig,
        $g_SusDB, $gX_SusDB, $gXX_SusDB;
    var $total_sig_count;

    /**
     * Use this method as a class constructor.
     * @param mixed $config
     */
    function construct($config = null)
    {
        // Instantiate the logger class
        $this->logger = new CwisLogger();

        // Use configuration options
        if (gettype($config) === 'object') {
            $this->logger->setScanPath($config->getScanPath());
        }
    }

    /**
     * Checks the file / DB record contents for signatures matches.
     * @param string $contents
     * @param string $sig_name
     * @param bool $is_preg
     * @return bool|array
     */
    function checkContents($contents = '', $sig_name = '', $is_preg = true)
    {
        // Process defined signatures only
        if (!$sig_name || !isset($this->{$sig_name})) {
            $response = new \App\Library\CwisResponse();
            $response->jsonError('Undefined signature name "' . $sig_name . '".');
        }

        $matches = array();

        // Check RegExp signatures in the loop
        foreach ($this->{$sig_name} as $index => $pattern) {
            if (!$pattern) {
                continue;
            }

            if (!$is_preg) {
                // Match non-regexps signatures (the patterns should be already lowercased)
                if (false !== ($position = strpos($contents, $pattern))) {
                    return array(
                        'index'	 => $index,
                        'regexp' => $pattern,
                        'offset' => $position,
                        'sigid'	 => $this->myCheckSum($pattern)
                    );
                }
            } else {
                $offset = 0;
                while (preg_match('#(' . $pattern . ')#smiS', $contents, $matches, PREG_OFFSET_CAPTURE, $offset)) {

                    // Check for exception found
                    if (!$this->checkException($contents, $matches)) {

                        // Get signature ID (the checksum)
                        $checksum = $this->getMatchSigId($matches);
                        if (null === $checksum) {
                            $checksum = $this->myCheckSum($pattern);
                        }

                        return array(
                            'index'	 => $index,
                            'regexp' => $pattern,
                            'offset' => $this->getMatchOffset($matches),
                            'sigid'	 => $checksum
                        );
                    }

                    // Shift to the next offset
                    $offset = $matches[0][1] + 1;
                }
            }
        }

        return false;
    }

    /**
     * Checks for exception found.
     * @param string $contents
     * @param array $matches
     * @return bool
     */
    function checkException($contents = '', $matches = array())
    {
        $offset = isset($matches[2][1]) ? $matches[2][1] : $matches[0][1];
        $matches_string = substr($contents, max($offset - 64, 0), 192);
        foreach ($this->g_ExceptFlex as $exceptItem) {
            if ($exceptItem && @preg_match('#(' . $exceptItem . ')#smi', $matches_string)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Returns total signatures count.
     * @return int
     */
    function getCount()
    {
        return $this->total_sig_count;
    }

    /**
     * Returns the offset matched.
     * @param array $matches
     * @return int
     */
    function getMatchOffset($matches = array())
    {
        $offset = 0;
        foreach ($matches as $val) {

            // Skip negative offsets
            if (!isset($val[1]) || $val[1] <= 0) {
                continue;
            }

            // Skip equal offsets
            if ($offset !== $val[1]) {
                $offset = $val[1];
            } else {
                break;
            }
        }

        return $offset;
    }

    /**
     * Returns the signature ID matched.
     * @param array $matches
     * @return int
     */
    function getMatchSigId($matches = array())
    {
        foreach ($matches as $key => $val) {

            // Extract SigId (CRC) from a group name (?<Xname>)
            if (is_string($key) && $val[1] !== -1 && strlen($key) === 9) {
                return substr($key, 1);
            }
        }

        return null;
    }

    /**
     * Returns the checksum of a string.
     * @param string $str
     * @return string
     */
    function myCheckSum($str = '')
    {
        if (function_exists('hash')) {
            $crc = hash('crc32b', $str);
        } else {
            $crc = dechex(crc32($str));
        }

        return $crc;
    }

    /**
     * Optimizes regExp-signatures.
     */
    function optimize()
    {
        if (State::cwisDebug() >= 3) {
            $this->logger->scanLogMessage('Optimizing signatures...');
        }

        $this->optSig($this->g_WebShells);
        $this->optSig($this->gX_WebShells);

        $this->optSig($this->g_FlexDBShe);
        $this->optSig($this->gX_FlexDBShe);
        $this->optSig($this->gXX_FlexDBShe);

        $this->optSig($this->g_JSVirSig);
        $this->optSig($this->gX_JSVirSig);

        $this->optSig($this->g_AdwareSig);
        $this->optSig($this->gX_AdwareSig);

        $this->optSig($this->g_PhishSig);

        $this->optSig($this->g_SusDB);
        $this->optSig($this->gX_SusDB);
        $this->optSig($this->gXX_SusDB);
    }

    function read()
    {
        // One time loaded signatures
        $signatures = State::loadSignatures();
        if (!$signatures || !is_array($signatures)) {
            throw new \Exception('Cannot read from signatures file.');
        }

        return $signatures;
    }

    function unpack()
    {
        // Read signatures from a file
        $sig_from_file = $this->read();

        // Process array of signatures
        foreach ($sig_from_file as $sig_name => $sig_array) {
            if (!is_array($sig_array)) {
                error_log("CWIS " . State::version() . " | Invalid signature: " . $sig_name);
                continue;
            }

            // Skip signatures descriptions
            if (is_numeric($sig_name)) {
                continue;
            }

            // Unpack signatures
            foreach ($sig_array as $index => $sig_unpacked) {
                $index = (int) $index; // prevents str_repeat() errors

                // Optimize string signatures (see $this->checkContents source code for explanations)
                if ($sig_name === 'DBShe') {
                    $sig_unpacked = array_map('strtolower', $sig_unpacked);
                }

                // Compose the variable name and store a signature
                $var_name = 'g' . ($index ? str_repeat('X', $index) : '') . '_' . $sig_name;
                $this->{$var_name} = $sig_unpacked;
            }
        }

        // Merge exclusive signatures, since v1.6.7.9
        if (is_array($this->gXXX_DBShe)) {
            $this->g_DBShe = array_merge($this->gXXX_DBShe, $this->g_DBShe);
        }

        // Exclusive regExp signatures, since v1.6.7.8
        if (is_array($this->gXXX_FlexDBShe)) {
            $this->g_FlexDBShe = array_merge($this->gXXX_FlexDBShe, $this->g_FlexDBShe);
        }

        // Total signatures count
        $this->total_sig_count = $this->totalCount();
    }

    // --- PRIVATE METHODS ---

    /**
     * Returns "real" count of signatures, including the number of "OR"s occurrences in regexps.
     * @return int
     */
    function realCount($array = array())
    {
        if (!is_array($array)) {
            return false;
        }

        $count = 0;
        foreach ($array as $sig) {
            // Add the number of "OR"s occurrences
            $count += 1 + substr_count($sig, '|');
        }

        return $count;
    }

    /**
     * Returns total signatures count.
     * @return int
     */
    function totalCount()
    {
        // Count signatures
        $_WebShellsCount = $this->realCount($this->g_WebShells) + $this->realCount($this->gX_WebShells);
        $_DBSheCount = $this->realCount($this->g_DBShe) + $this->realCount($this->gX_DBShe) + $this->realCount($this->gXXX_DBShe);
        $_FlexCount = $this->realCount($this->g_FlexDBShe) + $this->realCount($this->gX_FlexDBShe) + $this->realCount($this->gXX_FlexDBShe) + $this->realCount($this->gXXX_FlexDBShe) +
            $this->realCount($this->g_ExceptFlex);
        $_SigCount = $this->realCount($this->g_AdwareSig) + $this->realCount($this->gX_AdwareSig) +
            $this->realCount($this->g_PhishSig) +
            $this->realCount($this->g_JSVirSig) + $this->realCount($this->gX_JSVirSig);
        $_SusDBCount = $this->realCount($this->g_SusDB) + $this->realCount($this->gX_SusDB) + $this->realCount($this->gXX_SusDB);

        return $_WebShellsCount + $_DBSheCount + $_FlexCount + $_SigCount + $_SusDBCount;
    }

    /**
     * Optimizes signatures.
     * @param array $sigs
     */
    function optSig(& $sigs)
    {
        // Extended logging and disabled sigs optimization
        $debug_enabled = State::cwisDebug() >= 3;

        // Validate RegExp expressions
        $this->optSigValidityCheck($sigs, $debug_enabled);

        // Sort and remove duplicate signatures
        $sigs = $this->optSigSortGetUnique($sigs);

        // Add SigId (?<checksum>)
        if ($debug_enabled) {
            $sigs = $this->optSigAddCheckSums($sigs);
        } else
            // Optimize signatures by merging (nearly 2x-speed gain)
            if (State::phpVersion() >= 50200) {
                $sigs = $this->optSigMergeSimilar($sigs);
            }
    }

    /**
     * Adds check sums to the RegExp signatures.
     * @param array $sigs
     * @return bool
     */
    function optSigAddCheckSums($sigs = array())
    {
        if (empty($sigs)) {
            return array();
        }

        // Add SigId (?<Xname>)
        foreach ($sigs as $k => $sig) {
            if ($sig) {
                // Use named group syntax for CRC holding, prepend with "X" (group name must start with a non-digit)
                $sigs[$k] = $sig . '(?P<X' . $this->myCheckSum($sig) . '>)';
            }
        }

        return $sigs;
    }

    /**
     * Merges optimized signatures.
     * @param array $sigs
     * @return array
     */
    function optSigMergeSimilar($sigs = array())
    {
        if (empty($sigs)) {
            return array();
        }

        $skipped = array();
        foreach ($sigs as $i => $s) {
            if (false !== strpos($s, '.+') || false !== strpos($s, '.*')) {
                // Skip dot-any expressions
                $skipped[] = $s;
                unset($sigs[$i]);
            }
        }

        $signatures = implode("\n", $sigs);
        for ($i = 32; $i >= 1; ($i > 4) ? $i -= 4 : --$i) {
            $preg_regex = '#'
                . '^(' // Begin $1: Start of line
                . '(?>' // Atomic group
                . '(?:\\\\.|\\[.+?\\]|[^(\n]|\((?:\\\\.|[^)(\n])++\))' // Non-capturing group
                . '(?:[*?+]\+?|)' // Non-capturing group
                . '){' . $i . ',}' // Atomic group quantifier
                . ')' // End $1: Main capturing group
                . '.*' // Any characters (except newline)
                . '(?:\\n\\1(?![{?*+]).+)+' // Non-capturing group
                . '#im'; // Insensitive, multi-line
            //
            // Original version, working correctly in PHP5.4+ only
            $signatures = preg_replace($preg_regex, 'optMergePrefixes', $signatures);
            $signatures = preg_replace_callback($preg_regex, 'optMergePrefixes', $signatures);
        }

        return array_merge(explode("\n", $signatures), $skipped);
    }

    /**
     * Sorts and removes duplicate signatures.
     * @param array $sigs
     * @return array
     */
    function optSigSortGetUnique($sigs = array())
    {
        if (empty($sigs)) {
            return array();
        }

        // associative
        asort($sigs);

        // optimized analog of array_unique
        return array_keys(array_flip($sigs));
    }

    /**
     * Checks validity of the RegExp signatures.
     * @param array $signatures
     * @param bool $debug
     * @return bool
     */
    function optSigValidityCheck(& $signatures, $debug = false)
    {
        $result = true;

        foreach ($signatures as $index => $regexp) {

            // To validate a RegExp just run it against null
            if (!$regexp || false === @preg_match('#(' . $regexp . ')#smiS', '')) {
                if ($debug) {
                    $error = error_get_last();
                    $this->logger->scanLogMessage('Invalid: "' . $regexp . '", ' . $error['message'] . '.');
                }

                // Remove invalid signatures
                unset($signatures[$index]);
                $result = false;
            }
        }

        return $result;
    }

}
