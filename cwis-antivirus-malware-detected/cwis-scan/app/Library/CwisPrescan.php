<?php

namespace App\Library;

use App\State;

class CwisPrescan
{
    use Definitions;

    // Path to prescan file
    var $prescan_filepath;

    //
    // Directories list
    var $data = array();

    /**
     * Use this method as a class constructor.
     * @param mixed $config
     * @param mixed $queue
     */
    function construct($config, &$queue)
    {
        // Instantiate the core classes
        $this->benchmark = new CwisBenchmark ();
        $this->logger = new CwisLogger();
        $this->utilities = new CwisUtilities();

        // Pass configuration options
        if (gettype($config) === 'object') {
            $this->config = $config;

            // Set scan path in logger and utilities classes
            $this->utilities->setScanPath($this->config->getScanPath());
            $this->logger->setScanPath($this->config->getScanPath());
        }

        // Build a prescan file name
        $this->prescan_filepath = $this->utilities->defineFilePath('prescan');

        // Pointer to scan queue object
        $this->queue = & $queue;
    }

    function getData()
    {
        return $this->data;
    }

    function setData($prescan_data)
    {
        $this->data = $prescan_data;
        $this->queue->prescan['discovered'] = count($this->data);
    }

    // --- FILE MANAGEMENT ---

    function clear()
    {
        return file_put_contents_safe($this->prescan_filepath, '');
    }

    function delete()
    {
        return is_file($this->prescan_filepath) ? unlink($this->prescan_filepath) : null;
    }

    function isExists()
    {
        return is_file($this->prescan_filepath);
    }

    // --- MAIN METHODS ---

    function getPathDepth($path = '')
    {
        return substr_count($path, '/') + substr_count($path, '\\');
    }

    /**
     * Queued directories scan with timeout check. Parameter rescan defines if we should rescan from start.
     * @param array $base_dirs
     * @param bool $rescan
     * @return array
     */
    function queuedDirectoriesPrescan($base_dirs = array(), $rescan = false)
    {
        // Scan timeout (1 second by default), subtract 2%
        $scan_timeout = /* $this->config->scan_timeout * */ .98;

        // Start the timer
        $timer = new \App\Library\CwisTimer();
        $timer->start();

        // Convert to array if needed
        if (!is_array($base_dirs)) {
            $base_dirs = array($base_dirs);
        }

        // Restore current prescan data or rescan from start
        $prescan_data = $rescan ? array() : $this->load();
        if (empty($prescan_data)) {
            if (!empty($base_dirs)) {
                // Create an initial directories list
                $prescan_data = $base_dirs;
            } else {
                // Nothing to do, quite prescan...
                $this->queue->prescan['depth'] = -1;
                $this->queue->prescan['completed'] = 1;

                // Save updated dir list
                $this->setData($prescan_data);
                return $prescan_data;
            }
        }

        // Process base directories
        $current_dir = '';
        foreach ($base_dirs as $base_dir) {

            // Directories prescan depth
            $base_dir_depth = $this->getPathDepth($base_dir);
            do {

                // Check if prescan depth limit has been reached
                if ($this->config->scan_depth >= 0 && $this->queue->prescan['depth'] >= $this->config->scan_depth) {
                    $this->queue->prescan['depth'] = -1;
                    break;
                }

                // Ckeck benchmark's timer for timeout (1 sec by default)
                if ($scan_timeout > 0 && $timer->isTimeUp($scan_timeout)) {
                    break;
                }

                $new_directories = array();
                $new_directories_found = 0;
                foreach ($prescan_data as $i => $current_dir_packed) {

                    // Unpack current directory name
                    $current_dir = $this->utilities->filenameExpand($current_dir_packed);

                    // Read the realpath and detect symlinks (works in WIN)
                    $current_dir_real = file_exists($current_dir) ? realpath($current_dir) : $current_dir;
                    if ($current_dir_real !== $current_dir) {
                        if (State::cnf('follow_symlinks')) {
                            $prescan_data[$i] = $current_dir = $current_dir_real; // set to realpath value
                        } else {
                            continue; // do not follow symlinks
                        }
                    }

                    // Current directory depth
                    $current_dir_depth = $this->getPathDepth($current_dir);
                    if ($current_dir_depth < $base_dir_depth + $this->queue->prescan['depth']) {
                        //$this->logger->debugMessage('Skip prescaned directory "' . $current_dir_packed . '"');
                        continue;
                    }

                    // Get subdirectories list (max_depth = 1) and shift $current_dir
                    $sub_directories = $this->utilities->recursiveDirectoryScan($current_dir, 1);
                    if (!empty($sub_directories) && null !== array_shift($sub_directories)) {
                        $new_directories_found += count($sub_directories);

                        // Merge the subdirectories found
                        $new_directories = array_merge($new_directories, $sub_directories);
                    }
                }

                // The deepest point is reached
                if (!$new_directories_found) {
                    $this->queue->prescan['depth'] = -1;
                    break;
                }

                $this->queue->prescan['depth'] ++;
                $this->logger->debugMessage('Prescan depth is ' . $this->queue->prescan['depth']);

                // Merge the subdirectories found
                $prescan_data = array_merge($prescan_data, $new_directories);
            } while ($this->queue->prescan['depth'] >= 0);
        }

        // Set pre-prescan progress path
        if ($current_dir) {
            $this->queue->setProgress($current_dir . DIRECTORY_SEPARATOR);
        }

        // Remove duplicates
        $prescan_data_unique = array_unique($prescan_data);

        // Save updated dir list
        $this->setData($prescan_data_unique);
        $this->save();

        return $prescan_data_unique;
    }

    /**
     * Loads list of "packed" directory names.
     * @return array
     */
    function load()
    {
        $prescan_data = array();

        // Restore directories list from a file
        if (($prescan_data = file_get_array($this->prescan_filepath))) {
            $this->setData($prescan_data);
        }

        return $prescan_data;
    }

    /**
     * Saves list of "packed" directory names.
     * @return array
     */
    function save()
    {
        // Pack dir names
        $dir_names_buffer = '';
        foreach ($this->data as $dir_name) {
            $dir_names_buffer .= $this->utilities->filenameShrink($dir_name) . "\n";
        }

        if (false === file_put_contents_safe($this->prescan_filepath, $dir_names_buffer)) {
            header('HTTP/1.0 500 Internal Server Error');
            die('Cannot write prescan data to file.');
        }
    }

}
