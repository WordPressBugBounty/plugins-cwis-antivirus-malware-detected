<?php

namespace App\Library;

use App\State;

class CwisProgress
{
    use Definitions;

    // SCAN RESULTS (since v1.8.1.6)
    // -------------------------------------------------------
    // Every var is an array that MUST contain a "file" and
    // MAY contain the "fragment" and/or "sig" properties.
    var $results = array(
        'Vulnerable'		 => array(),
        'VulnerCMS'			 => array(),
        // --- CRITICAL (5 types) ---
        'CriticalJS'		 => array(),
        'CriticalPHP'		 => array(),
        'Htaccess'			 => array(),
        'Phishing'			 => array(),
        'WebShells'			 => array(),
        // --- INFO (8 types) ---
        'BigFiles'			 => array(),
        'GitFiles'			 => array(),
        'HiddenFiles'		 => array(),
        'NotRead'			 => array(),
        'PrivateIP'			 => array(),
        'SkippedDirs'		 => array(),
        'SymLinks'			 => array(),
        'Whitelisted'		 => array(),
        // --- WARNINGS (4 types) ---
        'AdwareList'		 => array(),
        'Doorways'			 => array(),
        'EmptyLinks'		 => array(),
        // --- SUSP (5 types) ---
        'Heuristic'			 => array(),
        'Iframer'			 => array(),
        'MaliciousCode'		 => array(),
        'PHPCodeInside'		 => array(),
        'UnixExec'			 => array(),
        'VulnerCode'		 => array(),
        // --- DETAILS (DEPRECATED) ---
        'EntryCRC'			 => array(),
        'EntryDetails'		 => array(),
        // --- CMS/PLUGINS DETECTED ---
        'DetectedCMS'		 => array(),
        'DetectedPlugins'	 => array(),
        // --- IGNORE LISTS ---
        'DirIgnoreList'		 => array(),
        'FileIgnoreList'	 => array(),
        'IgnoredExt'		 => array(),
        'UrlIgnoreList'		 => array(),
    );

    /**
     * Use this method as a class constructor.
     * @param mixed $config
     * @param mixed $queue
     * @param mixed $benchmark
     */
    function construct($config, &$queue, &$benchmark)
    {

        // Pass configuration options
        if (gettype($config) === 'object') {
            $this->config = $config;
        }

        // Instantiate the core classes
        $this->utilities = new CwisUtilities();
        $this->utilities->setScanPath($this->config->getScanPath());

        // Build a progress and results file names
        $this->progress_filepath = $this->utilities->defineFilePath('progress');
        $this->results_filepath = $this->utilities->defineFilePath('results');

        // Pointer to scan queue object
        $this->queue = & $queue;

        // Pointer to benchmark object
        $this->benchmark = & $benchmark;
    }

    /**
     * Adds a scan result to results array.
     * @param string|null $var
     * @param string $name
     * @param string $type
     * @param bool $skip_empty
     * @return bool
     */
    function pushScanResult($var = null, $name = '', $type = 'info', $skip_empty = false)
    {
        if (null === $var) {
            $scan_result = array();
        } else {
            if (!$var || ($skip_empty && empty($this->results[$var]))) {
                return false;
            }

            // Get scan result
            $scan_result = $this->results[$var];
        }

        // Validate result type
        if ($type !== 'vuln' && $type !== 'crit' && $type !== 'warn' && $type !== 'susp') {
            $type = 'info';
        }

        // Make sure that results property is exists
        if (!isset($this->queue->results)) {
            $this->queue->results = array();
        }

        if (($count = count($scan_result)) >= 0) {
            $this->queue->results[] = array(
                'count'	 => $count,
                'name'	 => $name,
                'type'	 => $type
            );
        }

        return true;
    }

    function createData($update_time_taken = true)
    {
        // Update progress benchmarks and memory usage
        $this->queue->updateBenchmarks($this->benchmark);

        // Update config data, scan progress, timers...
        $time_taken = $update_time_taken ? $this->benchmark->calculateTimeTaken(3, false) : 0;
        $this->queue->updateProgress($this->config, $time_taken);

        // Update versions (if not defined)
        if (!$this->queue->versions['current']) {
            $this->queue->updateVersions();
        }

        /////////////////////////////////////////////////////////////////////
        // Clear previous scan results
        $this->queue->results = array();
        foreach ($this->config->report_vars as $threat_type => $report_vars) {
            foreach ($report_vars as $var => $name) {
                $this->pushScanResult($var, $name, $threat_type);
            }
        }

        // PHP info (added after prescan finished)
        if ($this->queue->prescan['percent'] > 0) {
            $this->pushScanResult(null, State::msg('_CWIS_RESULT_PHP_INFO'), 'info');
        }

        // Create the progress data object
        $progress_data = array(
            'queue'		 => $this->queue, // pointer to progress queue object (since v1.9.1.9)
            'results'	 => $this->results, // pass raw scan results (since v1.8.1.6)
        );

        return $progress_data;
    }

    /**
     * Creates and initializes a merged progress queue.
     * @return CwisQueue
     */
    function createMergedQueue()
    {
        $merged_queue = new CwisQueue();

        // Must reset initial offsets
        $merged_queue->prescan['discovered'] = 0;
        $merged_queue->rescan['discovered'] = 0;
        $merged_queue->rescan['offset'] = 0;
        $merged_queue->scan['offset'] = 0;

        // Set initial statuses to "completed"
        $merged_queue->prescan['depth'] = -1;
        $merged_queue->prescan['completed'] = 1;
        $merged_queue->prescan['cmsplgs'] = 1;
        $merged_queue->prescan['cmsvers'] = 1;
        $merged_queue->rescan['completed'] = 1;
        $merged_queue->scan['completed'] = 1;
        $merged_queue->tables['completed'] = 1;

        // Set initial timestamps to "now"
        $merged_queue->time['timelast'] = time();
        $merged_queue->time['timestamp'] = time();

        return $merged_queue;
    }

    /**
     * Merges progress data from different scan paths.
     * @param string $scan_path_original
     * @param bool $queue_only Merge only queue data.
     * @return bool
     */
    function mergeProgressData($scan_path_original = '', $queue_only = false)
    {
        $scan_paths = $this->utilities->splitScanPath($scan_path_original);
        $config = $this->config;
        $queue = new CwisQueue();

        // Progress data
        $merged_queue = $this->createMergedQueue();
        $merged_results = array();

        // Copy user data
        $merged_queue->userinfo = $this->queue->userinfo;

        // Create empty results
        $cwisResults = new \App\Library\CwisResults();
        $cwisResults->emptyResults();

        // Merge progress data
        if (is_array($scan_paths)) {
            foreach ($scan_paths as $scan_path) {

                // Load the progress data
                $config->setScanPath($scan_path, $realpath = true);
                $this->construct($config, $queue, $this->benchmark);
                if (!$queue_only) {
                    $progress_data = $this->load($measure_time_taken = false);
                } else {
                    $progress_data = array();
                    $progress_data['queue'] = $this->loadQueue();
                }

                // Merge scan progress (queue data)
                $merged_queue->mergeScanProgress($progress_data['queue']);
                unset($progress_data['queue']);

                // Merge scan results (raw report data)
                if (!$queue_only) {
                    $merged_results = $cwisResults->mergeScanResults($progress_data['results']);
                }

                // Free up memory
                unset($progress_data);
            }
        }

        // Restore original scan_path in queue
        $config->setScanPath($scan_path_original);
        $merged_queue->updateProgress($config);

        // Progress data
        return array(
            'queue'		 => $merged_queue,
            'results'	 => $merged_results
        );
    }

    /**
     * Synchronizes the content of the first object with the second one.
     * @param mixed $obj1
     * @param mixed $obj2
     * @return null
     */
    function synchronizeProgressData($obj1, $obj2, $strict = true)
    {
        if (
            (!$strict && empty($obj1)) || // strict sync
            (!is_object($obj1) && !is_array($obj1))
        ) {
            return $obj2;
        }

        // Get obj1 type
        $is_object = is_object($obj1);
        $is_array = is_array($obj1);

        // Loop recursively
        foreach ($obj1 as $prop => $val1) {
            if ($is_object && isset($obj1->$prop) && isset($obj2->$prop)) {
                $obj1->$prop = $this->synchronizeProgressData($val1, $obj2->$prop, $strict);
            } elseif ($is_array && isset($obj1[$prop]) && isset($obj2[$prop])) {
                $obj1[$prop] = $this->synchronizeProgressData($val1, $obj2[$prop], $strict);
            }
        }

        return $obj1;
    }

    function restoreData(& $progress_data, $measure_time_taken = false)
    {
        // Set progress data
        if (!isset($progress_data['queue']) && $this->queue) {
            $progress_data['queue'] = $this->queue;
        }

        // Restore the last state of the queue
        if (isset($progress_data['queue']) && $this->queue) {
            $progress_data_queue = $progress_data['queue'];

            // Restore CPU benchmark data
            if (isset($progress_data_queue->system) && !defined('CPU_BENCHMARK')) {
                define('CPU_BENCHMARK', $progress_data_queue->system['cpumark']);
            }

            // Restore scan path
            if (!$progress_data_queue->scan['path']) {
                $progress_data_queue->scan['path'] = $this->config->getScanPath($relative = true);
            }

            // Synchronize user info
            $progress_data_queue->userinfo = $this->queue->userinfo;

            // Store the actual app version
            $progress_data_queue->version = State::version();

            // Override license type and userinfo (since v2.3.0)
            if (($is_license_updated = ($progress_data_queue->scan['license'] !== State::cnf('license')))) {
                $progress_data_queue->scan['license'] = State::cnf('license');

                /*
                  // Reset scan progress status if switched from a FREE version
                  if ($this->config->isPremium() && $progress_data_queue->scan['percent'] < 100) {
                  $progress_data_queue->scan['completed'] = 0;
                  $progress_data_queue->tables['completed'] = 0;
                  }
                 */

                // Save data on license type change
                $this->saveSerializedData($this->progress_filepath, $progress_data_queue);
            }

            // Synchronize with the default queue
            $queue = $this->synchronizeProgressData(new CwisQueue(), $this->queue);
            $this->queue = $this->synchronizeProgressData($queue, $progress_data_queue);

            // Pass previous system errors to next JSON
            /* if (!empty($progress_data_queue->errors)) {
              foreach ($progress_data_queue->errors as $message) {
              $this->queue->errors[] = $message;
              }
              } */

            // Pass previous system messages to next JSON
            if (!empty($progress_data_queue->messages)) {
                foreach ($progress_data_queue->messages as $message) {
                    if (false !== strpos($message, 'SQLSTATE')) {
                        $this->queue->messages[] = $message;
                    }
                }
            }

            // Update benchmark's timer
            if ($measure_time_taken || (isset($this->queue->scan['offset']) && $this->queue->scan['offset'] < 0)) {
                $this->queue->time['taken'] = $this->benchmark->calculateTimeTaken();
            }

            // Instantiate the benchmark class
            if (isset($this->queue->time['throttled'])) {
                $this->benchmark->time_cpu_throttled = $this->queue->time['throttled'];
            }
        }

        // Restore scan results (since v1.8.1.6)
        // -------------------------------------------------------
        // Every var is an array that MUST contain a "file" and
        // MAY contain the "fragment" and/or "sig" properties.
        $results = isset($progress_data['results']) ?
            $progress_data['results'] : array();
        foreach ($this->results as $var => $array) {
            if (isset($results[$var])) {
                $this->results[$var] = $array = $results[$var];
            }

            if (!is_array($array)) {
                $this->results[$var] = array();
            }
        }
    }

    function delete()
    {
        return $this->isExists() ? unlink($this->progress_filepath) && unlink($this->results_filepath) : null;
    }

    /**
     * Checks if the PROGRESS_FILEPATH is exists.
     * @return bool
     */
    function isExists()
    {
        return is_file($this->progress_filepath) && is_file($this->results_filepath);
    }

    function save($update_time_taken = true)
    {
        // Prepare progress data
        $progress_data = $this->createData($update_time_taken);

        // Save queue and results data separately
        if (!$this->saveQueue($progress_data['queue']) || !$this->saveResults($progress_data['results'])) {
            return false;
        }

        return $progress_data;
    }

    function saveQueue($queue = null)
    {
        return $this->saveSerializedData($this->progress_filepath, $queue);
    }

    function saveResults($results = null)
    {
        return $this->saveSerializedData($this->results_filepath, array(State::cnf('CWIS_SIGNATURE')) + $results);
    }

    /**
     * @param $measure_time_taken
     * @param $queue_only
     * @return array
     */
    function load($measure_time_taken = false, $queue_only = false)
    {
        // Prepare progress data
        $progress_data = array(
            'queue'		 => $this->queue,
            'results'	 => $this->results
        );

        // Load queue and (optionally) results
        $progress_data['queue'] = $this->loadQueue();
        if (!$queue_only) {
            $progress_data['results'] = $this->loadResults();
        }
        $this->restoreData($progress_data, $measure_time_taken);

        return $progress_data;
    }

    function loadQueue()
    {
        return is_file($this->progress_filepath) ?
            $this->loadSerializedData($this->progress_filepath) : null;
    }

    function loadResults()
    {
        return is_file($this->results_filepath) ?
            $this->loadSerializedData($this->results_filepath) : null;
    }

    // --- PRIVATE METHODS ---

    function loadSerializedData($filepath = '')
    {
        $serialized_data = file_get_contents_safe($filepath);
        return $serialized_data ? @unserialize($serialized_data) : null;
    }

    function saveSerializedData($filepath = '', $data = '')
    {
        $serialized_data = serialize($data);
        return (false !== file_put_contents_safe($filepath, $serialized_data));
    }

}
