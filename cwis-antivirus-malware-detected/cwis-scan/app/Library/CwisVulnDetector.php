<?php

namespace App\Library;

use App\State;

class CwisVulnDetector
{

    // Classes instances
    var $results;
    //
    // Report name
    var $var_name, $report_name;

    /**
     * Use this method as a class constructor.
     * @param mixed $config
     * @param mixed $results
     * @param string $var_name
     */
    function construct($config, &$results, $var_name = 'Vulnerable')
    {
        // Pass a results object
        if (gettype($results) === 'object') {
            $this->results = & $results;

            // Select report name
            $this->var_name = $var_name;
        }

        // Instantiate the core classes
        $this->logger = new \App\Library\CwisLogger();
        $this->utilities = new \App\Library\CwisUtilities();

        // Use configuration options
        if (gettype($config) === 'object') {
            $this->logger->setScanPath($config->getScanPath());
        }
    }

    /**
     * Checks for known CMS and plugin vulnerabilities using textual knowledge base.
     * @param array $cms_list
     * @param array $plugin_list
     * @return bool
     */
    function checkVulnerableCMSPlugins($cms_list = array(), $plugin_list = array())
    {
        // Get vulnerabilities knowledge base contents as a plain text
        $vuln_kb_plain = file_get_contents_safe(State::makePath([State::listsPath(), '.vulnerable']));

        // Split knowledge base content by sections
        $vuln_kb_sections = $matches = array();
        if (preg_match_all('#^===\s*(.+?)\s*===\s*$#sm', $vuln_kb_plain, $matches, PREG_OFFSET_CAPTURE)) {
            $n = count($matches[0]);
            for ($i = 0; $i < $n; $i++) {
                $match = $matches[0][$i][0];
                $cms_name = $matches[1][$i][0];
                $start = $matches[0][$i][1] + strlen($match);
                if ($i < $n - 1) {
                    $end = $matches[0][$i + 1][1];
                    $vuln_kb_sections[$cms_name] = trim(substr($vuln_kb_plain, $start, $end - $start));
                } else {
                    $vuln_kb_sections[$cms_name] = trim(substr($vuln_kb_plain, $start));
                }
            }
        }

        // Exit on empty (section) list
        if (empty($vuln_kb_sections)) {
            return false;
        }

        // 1. Process list of CMS found
        $this->report_name = 'VulnerCMS';
        if (is_array($cms_list)) {
            foreach ($cms_list as $cms_path => $cms_detected) {
                if (!is_array($cms_detected)) {
                    $cms_detected = array($cms_detected);
                }

                foreach ($cms_detected as $cms_name_version) {
                    list($cms_name, $cms_version) = array_pad(explode("\t", $cms_name_version), 2, '');

                    // Use related knowledge base section or do nothing
                    if (isset($vuln_kb_sections[$cms_name])) {
                        $vuln_kb_section = $vuln_kb_sections[$cms_name];
                        $this->checkVulnerableCMSPlugin($vuln_kb_section, $cms_path, $cms_name, $cms_version);
                    }
                }
            }
        }

        // 2. Process list of plugins found
        $this->report_name = $this->var_name;
        if (is_array($plugin_list)) {
            foreach ($plugin_list as $plugin_path => $plugin_name_version) {
                list($cms_name, $plugin_name, $plugin_version) = array_pad(explode("\t", $plugin_name_version), 3, '');

                // Use related knowledge base section or do nothing
                if (isset($vuln_kb_sections[$cms_name])) {
                    $vuln_kb_section = $vuln_kb_sections[$cms_name];
                    $this->checkVulnerableCMSPlugin($vuln_kb_section, $plugin_path, $plugin_name, $plugin_version);
                }
            }
        }

        return true;
    }

    // --- PRIVATE METHODS ---

    /**
     * Checks CMS or plugin for vulnerabilities using textual knowledge base.
     * @param string $vuln_kb_section
     * @param string $plugin_path
     * @param string $plugin_name
     * @param string $plugin_ver
     * @return bool
     */
    function checkVulnerableCMSPlugin($vuln_kb_section = '', $plugin_path = '', $plugin_name = '', $plugin_ver = '')
    {
        if (!$plugin_path || !$plugin_name) {
            return false;
        }

        // Build regexp for plugin search
        $plugin_name_regexp = '#^(?P<date>[\d\-]{10}\s+)?'
            . '\*\s+' . preg_replace('/\W+/', '\W*', $plugin_name) // simplify plugin name
            . '\s+\[version(?P<vers>[^\]]+)\]' // vulnerable version(s)
            . '(?P<descr>.*)$#mi'; // vulnerability description
        //
        // Search in knowledge base
        $matches = array();
        if (!preg_match_all($plugin_name_regexp, $vuln_kb_section, $matches, PREG_OFFSET_CAPTURE)) {
            return false;
        }

        // Select report name
        $this->results->select($this->report_name);

        // Matched vulnerability description(s) and version(s)
        foreach ($matches['vers'] as $index => $array) {
            $vuln_description = trim($matches['descr'][$index][0]);
            $vuln_versions_array = explode(',', $vuln_versions = $array[0]);

            // Versions range check
            if ($this->checkVulnerableCMSPluginVersion($plugin_ver, $vuln_versions_array)) {

                // Built and push result (can't use method chaining in PHP4)
                $result_entry_data = array('name'		 => $plugin_path,
                    'fragment'	 => $plugin_name . ' v' . $plugin_ver . ' : ' . ($vuln_description ? $vuln_description : 'VULN : ' . $plugin_name),
                    'stat'		 => @stat($this->utilities->filenameExpand($plugin_path)));
                $this->results->buildEntry($result_entry_data);
                $this->results->push();
            } elseif (State::cwisDebug() >= 2) {
                $this->logger->debugMessage('checkVulnerableCMSPlugin("' . $plugin_name . '", !' . $plugin_ver . $vuln_versions . ')');
            }
        }

        return true;
    }

    /**
     * Checks version of the vulnerable CMS or plugin.
     * @param string $plugin_ver
     * @param array $versions
     * @return bool
     */
    function checkVulnerableCMSPluginVersion($plugin_ver = '', $versions = array())
    {
        // Versions range check
        $version_compare_result = $matches = array();
        foreach ($versions as $vuln_version) {
            if (!preg_match('#([<=>]+)\s+v?(.*)#', $vuln_version, $matches)) {
                continue;
            }

            // Comparison operator and version
            $operator = trim($matches[1]);
            $version = trim($matches[2]);
            if (isset($version_compare_result[$operator])) {
                break; // logical "OR" for identical operators
            }

            // Compare versions
            $version_compare_result[$operator] = version_compare($plugin_ver, $version, $operator);
        }

        // Check compare result
        if (!empty($version_compare_result) && !in_array(false, $version_compare_result)) {
            return true;
        }

        return false;
    }

}
