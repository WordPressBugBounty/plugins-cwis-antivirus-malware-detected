<?php

namespace App\Library;

use App\State;

define('CW_TOTP_ALPHABET',      'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567');
define('CW_TOTP_TIMESTEP',      '30');
define('CW_TOTP_TIMEWINDOW',    '2');
define('CW_TOTP_TOKENLENGTH',   '6');
define('CW_TOTP_TOKENCEILING',  '1000000');

class CwisTOTP {

  public static function gen_totp_key() {
  	$alphabet = str_split(CW_TOTP_ALPHABET);
  	$key = '';
  	for ($i = 0; $i < 16; $i++) $key .= $alphabet[mt_rand(0,31)];
  	return $key;
  }

  public static function TimeStamp() {
    return floor(microtime(true)/CW_TOTP_TIMESTEP);
  }

  public static function B32toB($inarg) {

    $inarg  = strtoupper($inarg);
    if (!preg_match('/^[A-Z2-7]+$/', $inarg))
       throw new \Exception('Invalid characters in the base32 string.');
    $n = $j = 0;
    $result = "";
    for ($i=0; $i<strlen($inarg); $i++) {
       $n = $n << 5;           // Each character gets 5 bits
       $c = ord($inarg[$i]);
       $c -= ($c>64) ? 65 : 24;  // A-Z or 2-7
       $n += $c;
       $j += 5;
       if ($j > 7) {
          $j -= 8;
          $result .= chr(($n & (0xFF << $j)) >> $j);
          }
       }
    return $result;

  }

  // HMAC-Based One-Time Password Algorithm from RFC 4226
  public static function MakeOTP($secretKey, $timeval) {

    if (strlen($secretKey) < 8)
       throw new \Exception('Secret key must contain at least 16 base 32 characters');
    $bTimeval = pack('N*', 0) . pack('N*', $timeval);    // Timeval must be 64-bit int
    $hash = hash_hmac ('sha1', $bTimeval, $secretKey, true);
    $offset = ord($hash[19]) & 0xf;
    $token =
       ((ord($hash[$offset+0]) & 0x7f) << 24 ) |
       ((ord($hash[$offset+1]) & 0xff) << 16 ) |
       ((ord($hash[$offset+2]) & 0xff) << 8 ) |
       ( ord($hash[$offset+3]) & 0xff) ;
    while($token>CW_TOTP_TOKENCEILING) $token -= CW_TOTP_TOKENCEILING;
    return str_pad($token, CW_TOTP_TOKENLENGTH, '0', STR_PAD_LEFT);

  }

  public static function TestKey($secretKey, $testkey) {

    if(State::cwisDebug() == '1') {
      return true;
    }

    $tStamp = self::TimeStamp();
    $bSecretKey = self::B32toB($secretKey);
    for ($ts=-CW_TOTP_TIMEWINDOW; $ts<=CW_TOTP_TIMEWINDOW; $ts++) {
      $t = self::MakeOTP($bSecretKey, $tStamp+$ts);
      if ($t == $testkey) return true;
    }
    return false;

  }

}
