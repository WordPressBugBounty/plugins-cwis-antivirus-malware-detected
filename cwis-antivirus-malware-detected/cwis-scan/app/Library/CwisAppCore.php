<?php

namespace App\Library;

use App\State;
use App\Library\CwisApi;

class CwisAppCore extends CwisApp
{
    protected function isCli() : bool
    {
        return (State::isCli() && !State::cnf('CWIS_IS_CGI'));
    }

    function initCoreScanPath()
    {
        // Set scan path in logger and utilities classes
        $this->logger->setScanPath($this->config->getScanPath());
        $this->utilities->setScanPath($this->config->getScanPath());

    }

    // --- Shared access rights ---

    /**
     * Check shared access rights (the semaphore file is used to manage the concurrent requests).
     * @return bool
     */
    function checkSharedAccessRights()
    {
        // Use the semaphore file to manage the concurrent requests
        $shared_filepath = $this->utilities->defineFilePath('shared');
        if (is_file($shared_filepath) && time() - filemtime($shared_filepath) <= 10) {
            return false;
        }
        // Check if server scanning or rescanning is not finished
        elseif ($this->config->scan_type > 0 && !$this->queue->isScanFinished() && !$this->queue->isRescanFinished()) {

            // Create the shared file
            file_put_contents_safe($shared_filepath, time());
        }

        return true;
    }

    function lockSharedAccessRights()
    {
        // Use the semaphore file to manage the concurrent requests
        $shared_filepath = $this->utilities->defineFilePath('shared');
        return @touch($shared_filepath);
    }

    function unlockSharedAccessRights()
    {
        // Delete old semaphore file (if exists)
        $shared_filepath = $this->utilities->defineFilePath('shared');
        if (is_file($shared_filepath)) {
            @unlink($shared_filepath);
        }
    }

    /**
     * Waits for access rights (manages concurrent requests).
     * @int $limit
     * @int $wait
     * @return bool
     */
    function waitForAccessRights($limit = 24, $wait = 40000)
    {

        // Use the semaphore file to manage the concurrent requests
        while ($limit-- > 0 && !$this->checkSharedAccessRights()) {
            $this->logger->debugMemoryUsage('--- Scan:Wait ---');

            // Wait (40ms by default)
            usleep($wait);
        }

        // Skip concurrent requests
        if ($limit <= 0 && !State::isCli()) {
            $this->logger->debugMemoryUsage('--- Scan:Shared ---');

            // Clear scan type to "Cache"
            $this->config->scan_type = 0;
            return false;
        }

        return true;
    }

    // --- Prescan and scan methods ---

    /**
     * Checks if scanning timeout reached.
     * @return bool
     */
    function isScanTimeout()
    {
        return (bool) ($this->config->scan_timeout > 0 && $this->benchmark->calculateTimeTaken() >= $this->config->scan_timeout);
    }

    function processPrescanedCMS()
    {

        // Run the CMS detector (defines systems and versions)
        if ($this->queue->prescan['cmsvers'] < 1) {

            // Write to stdout
            if (State::isCli() && !State::cnf('api_mode')) {
                $this->scanner->stdoutPrintProgress(State::msg('_CWIS_MESSAGE_DETECTING_WEBSITE_CMS'));
            }

            // Load a pre-scanned dirs list
            $prescan_data = $this->prescan->load();

            // Detect version of CMS by analysing dirs list
            $this->queue->addMessage(State::msg('_CWIS_MESSAGE_DETECTING_WEBSITE_CMS'));
            $this->scanner->detectCMSVersion($prescan_data);

            // Update CMS detector status
            $this->queue->prescan['cmsvers'] = 1;
        }

        // Run the plugins detector (defines names and versions)
        if ($this->queue->prescan['cmsplgs'] < 1) {

            // List of directories with CMS
            $dir_list = isset($this->progress->results['DetectedCMS']) ?
                array_keys($this->progress->results['DetectedCMS']) : array();

            // Write to stdout
            if (State::isCli() && !State::cnf('api_mode')) {
                $this->scanner->stdoutPrintProgress(State::msg('_CWIS_MESSAGE_DETECTING_CMS_PLUGINS'));
            }

            // Detect which plugins are installed
            $this->queue->addMessage(State::msg('_CWIS_MESSAGE_DETECTING_CMS_PLUGINS'));
            $this->scanner->detectCMSPlugins($dir_list);

            // Check for vulnerable CMS and plugins
            $this->scanner->checkVulnerableCMSPlugins();

            // Update plugins detector status
            $this->queue->prescan['cmsplgs'] = 1;

            // Set prescan status to "completed" (quick rescan)
            if ($this->queue->prescan['processed'] >= $this->queue->prescan['discovered']) {
                $this->queue->prescan['completed'] = 1;
            }

            return true;
        }
    }

    function processPrescanedDirList()
    {
        // Load a pre-scanned dirs list
        $prescan_data = $this->prescan->load();

        // Load ignored extensions
        $this->scanner->loadIgnoredExt();

        // Preload ignore lists
        $this->scanner->loadIgnoreLists();

        // Process prescaned directories list
        $this->queue->addMessage(State::msg('_CWIS_MESSAGE_PROCESSING_PRESCANED_DIRS'));
        $this->scanner->processPrescanedDirectories($prescan_data);

        // Set prescan status to "completed" and scan offset to "0" (zero) to start the scanning
        if ($this->queue->prescan['processed'] >= $this->queue->prescan['discovered']) {
            $this->queue->prescan['completed'] = 1;
            $this->queue->scan['offset'] = 0;
        }
    }

    function processPrescanedDatabaseTables($scan_path_packed = '')
    {
        $scan_path = $this->utilities->filenameExpand($scan_path_packed);

        // Read database settings
        $dbs = $this->utilities->getDatabaseSettingsFromFile($scan_path, $this->config->database);
        $this->logger->debugMessage('Database type: "' .
            $dbs['type'] . '", name: "' . $dbs['name'] . '", prefix: "' . $dbs['prefix'] . '"');

        // Exit if dbhost or dbuser not defined
        if (empty($dbs['host'])) {
            $this->queue->addMessage(State::msg('_CWIS_MESSAGE_DATABASE_HOST_UNDEFINED'));
            return false;
        }

        // Exit if dbhost or dbuser not defined
        if (empty($dbs['user'])) {
            $this->queue->addMessage(State::msg('_CWIS_MESSAGE_DATABASE_USERNAME_UNDEFINED'));
            return false;
        }

        // Open database connection
        if ($this->scanner->databaseOpenConnection($dbs['type'], $dbs['host'], $dbs['user'], $dbs['pass'], $dbs['name'])) {

            // Discover database tables (prescan)
            $tables = $this->scanner->databaseShowTables($dbs['name']);

            // Guess table names using known prefix
            if (empty($tables) && $dbs['name'] && $dbs['name'] !== '*') {
                $tables = $this->scanner->databaseKnownTablesCheck($dbs['name'], $dbs['prefix']);
            }

            // Processing the tables list...
            if ($this->queue->tables['discovered'] < 0) {
                $this->queue->addMessage(State::msg('_CWIS_MESSAGE_FETCHING_TABLES_LIST'));
                if ($tables) {
                    $this->queue->tables['discovered'] = count($tables);
                } else {
                    $this->queue->addMessage(State::msg('_CWIS_MESSAGE_UNABLE_FETCH_TABLES_LIST'));
                    $this->queue->tables['discovered'] = 0;
                }

                // Save debug info
                $this->logger->debugMessage('Available database driver(s): ' .
                    implode(', ', $this->scanner->pdo->getAvailableDrivers()) . '.');
                $this->logger->debugMessage('Number of tables in ' . $this->scanner->pdo->getDriver() . ' database: ' . count($tables));
            } else {
                // Load/optimize or use cached signatures
                if ($this->scanner->loadOptimizeSignatures()) {

                    // Load custom signatures
                    if (State::cnf('CWIS_DEBUG') >= 3) {
                        $this->scanner->loadCustomSignatures();
                    }

                    // Timeout correction (disabled 2016-11-15)
                    //$this->config->updateScanTimeout();
                }

                // Continuous database scan
                $this->queue->addMessage(sprintf(State::msg('_CWIS_MESSAGE_SCANNING_DATABASE_TABLES'), $this->scanner->pdo->getDriver()));
                $offset = $this->queue->tables['processed'];
                $this->progress->queue->tables['processed'] = $this->scanner->scanDatabase($tables, $offset);

                // Close connection
                $this->scanner->databaseCloseConnection();

                // Stop the scan process
                if ($this->queue->tables['processed'] >= $this->queue->tables['discovered']) {
                    $this->queue->tables['completed'] = 1;
                }
            }

            return true;
        } else {
            // Nothing to do, skipping...
            $message = $this->scanner->databaseGetErrorMessage();
            $this->queue->addMessage($message ? $message : 'Cannot connect to database.');
            return false;
        }
    }

    function processQueuedFullScanForThreats()
    {
        // Load/optimize or use cached signatures
        if ($this->scanner->loadOptimizeSignatures()) {

            // Timeout correction
            $this->config->updateScanTimeout();
        }

        // Scan and get the new offset
        $this->queue->addMessage($this->queue->prescan['discovered'] ? State::msg('_CWIS_MESSAGE_SCANNING_FILES_THREATS') : State::msg('_CWIS_MESSAGE_UNABLE_TO_SCAN_EMPTY_PATH'));
        $this->queue->scan['offset'] = $this->scanner->queuedScanForThreats($this->queue->scan['offset']);

        // Check if file scanning has been finished
        if ($this->scanner->isQueuedScanFinished()) {
            $this->queue->scan['completed'] = 1;

            // Log Scan:Finished event
            $event = !$this->config->isPremium() ? 'Finished' : 'Ended';
            $this->logger->debugMemoryUsage('--- Scan:' . $event . ' ---');
            error_log('CWIS ' . State::version() . ' | Scan:' . $event);
        }

        // Check in whitelist
        $this->scanner->checkWhitelist();
    }

    function processQueuedRescanSuspiciousFiles()
    {
        // TODO: optimize ignore lists load
        //---------------------------------
        // Load ignored extensions
        $this->scanner->loadIgnoredExt();

        // Preload ignore lists
        $this->scanner->loadIgnoreLists();

        // Load/optimize or use cached signatures
        if ($this->scanner->loadOptimizeSignatures()) {

            // Timeout correction
            $this->config->updateScanTimeout();
        }

        // Rescan and get the new offset
        $this->queue->addMessage(State::msg('_CWIS_MESSAGE_RESCANNING_FILES_THREATS'));
        $rescan_offset = $this->scanner->queuedRescanForThreats($this->queue->rescan['processed']);

        // Stop the rescan process?
        if ($rescan_offset < 0) {
            $this->queue->rescan['completed'] = 1;
            $this->queue->rescan['processed'] = $this->queue->rescan['discovered'];

            // Log Rescan:Ended event
            $this->logger->debugMemoryUsage('--- Rescan:Ended ---');
            error_log('CWIS ' . State::version() . ' | Rescan:Ended');
        } else {
            $this->queue->rescan['processed'] = $rescan_offset;
        }

        // Check in CRC hashes whitelist
        $this->scanner->checkWhitelist();
    }

    // --- High-level scan methods ---

    function continuousPrescan()
    {
        ///////////////////////////////////////////////////////////////
        // 4. Prescan root directory recursively and save the list
        if ($this->config->scan_type === 3 || (!$this->queue->isPrescanFinished() && !$this->prescan->isExists())) {

            // Start a new prescan based on $base_dir
            $this->prescan->queuedDirectoriesPrescan($this->config->getScanPaths(), $rescan = true);

            // Create progress data object without saving
            $this->progress_data = $this->progress->createData();
            if (!State::isCli()) { //send a faster response
                $this->config->scan_timeout = 1;
            }
        } elseif ($this->queue->prescan['depth'] >= 0) {

            // Continue queued prescan (base directories to start from)
            $this->prescan->queuedDirectoriesPrescan($this->config->getScanPaths(), $rescan = false);

            // Create progress data object without saving
            $this->progress_data = $this->progress->createData();
        }

        ///////////////////////////////////////////////////////////////
        // 5. Detect version of CMS and run the plugins detector
        // 6. Load the known signatures and ignore lists
        // 7. Recursively build a list of files for scanning
        if ($this->queue->prescan['depth'] < 0 &&
            ($this->queue->prescan['cmsvers'] < 1 || $this->queue->prescan['cmsplgs'] < 1 ||
                $this->queue->prescan['processed'] < $this->queue->prescan['discovered'])) {

            // Include scanner methods
            $this->initScannerMethods();

            // Process prescaned directories list
            if (!$this->processPrescanedCMS()) {
                $this->processPrescanedDirList();
            }
            return true;
        }

        return false;
    }

    function continuousScanTypeMode()
    {
        ///////////////////////////////////////////////////////////////
        // 8. Discover database tables
        // 9. Continuous database scan
        // 10. Update the config file and the queue pointer
        //
        // Skip database tables scanning?
        $this->queue->tables['skipped'] = !$this->config->scan_database ? 1 : 0;

        // Continue incomplete database scan (if CMS detected already)
        if ($this->queue->prescan['cmsvers'] >= 0 && !$this->queue->isDatabaseScanFinished()) {

            // Do not skip database scanning
            $this->queue->tables['skipped'] = 0;

            // Reset database scan status
            if ($this->queue->tables['discovered'] < 0) {
                $this->queue->tables['completed'] = 0;
            }

            // Include scanner methods
            $this->initScannerMethods();

            // List of directories with detected CMS
            $cms_list = isset($this->progress->results['DetectedCMS']) ?
                array_keys($this->progress->results['DetectedCMS']) : array();

            // Process CMS paths
            $status = false;
            if ($this->benchmark->getMemoryAvailable() > shorthand_to_bytes(State::cnf('MAX_SIZE_TO_SCAN'))) {
                if (!empty($cms_list)) {
                    foreach ($cms_list as $cms_path) {
                        if (false !== ($status = $this->processPrescanedDatabaseTables($cms_path))) {
                            break;
                        }
                    }
                } else {
                    // Process all scan paths, check DB config files (if any)
                    foreach ($this->config->getScanPaths() as $scan_path) {
                        if (false !== ($status = $this->processPrescanedDatabaseTables($scan_path))) {
                            break;
                        }
                    }
                }
            } else {
                $this->queue->addMessage('Could not scan the database. Not enough memory.');
            }

            // Finish DB scan on error
            if (false === $status) {
                $this->queue->tables['completed'] = 1;
                $this->queue->tables['discovered'] = 0;
            }
        }

        ///////////////////////////////////////////////////////////////
        // 11. The progress data loaded and restored from a config file
        // 12. Continue the scanning process and stop on timeout
        // 13. Save pointer to currently scanning file
        if ($this->queue->prescan['depth'] < 0 && $this->queue->prescan['processed'] >= $this->queue->prescan['discovered']) {
            if (!$this->queue->isScanFinished()) {

                // Include scanner methods
                $this->initScannerMethods();

                // Continue scan and get the new offset
                $this->processQueuedFullScanForThreats();
            }
        }
    }

    function continuousRescanTypeMode()
    {
        // Nothing to do if file scan is not finished
        if (!$this->queue->isFileScanFinished()) {
            return null;
        }

        // Continue rescan, process files...
        if ($this->config->scan_type >= 1 && !$this->queue->isFileRescanFinished()) {

            // Stage 1: Check if previous rescan has been completed or force restart if stacked
            if ($this->config->scan_type === 2 || $this->queue->rescan['modified'] < 0) {

                // Include scanner methods
                $this->initScannerMethods();

                // Reset and prepare for quick rescan
                $this->queue->addMessage(State::msg('_CWIS_MESSAGE_RUNNING_QUICK_RESCAN'));

                // Prepare a files list for quick rescan
                $qrs_files_list = $this->scanner->prepareRescanForThreats();
                $this->queue->rescan['discovered'] = count($qrs_files_list);
                $this->queue->rescan['modified'] = 0;

                // Save the rescan files list
                $rescan_filepath = $this->utilities->defineFilePath('rescan');
                if (false === file_put_contents_safe($rescan_filepath, implode("\n", $qrs_files_list) . "\n")) {
                    throw new \Exception('Cannot write rescan list to file.', 500);
                }
                unset($qrs_files_list);

                /* else {

                  // Delete prescan and progress data (eg "reload")
                  $this->prescan->delete();
                  $this->progress->delete();

                  // Log Scan:Reloaded event
                  $this->logger->debugMemoryUsage('--- Scan:Reloaded ---');
                  error_log("CWIS " . CWIS_VERSION . " | Scan:Reloaded");
                  $this->response->jsonError("The rescan data is corrupted.");
                  } */

                // Fix negative offset bug
                if ($this->queue->scan['files']['scanned'] < 0) {
                    $this->queue->scan['files']['scanned'] = 0;
                }

                return true;
            }

            // Stage 2: Prepare list of new or modified files to rescan
            if ($this->queue->rescan['modified'] < 1) {

                // Modified files rescan
                if ($this->config->isPremium()) {

                    // Include scanner methods
                    $this->initScannerMethods();

                    // Force reload of ignore lists
                    $this->scanner->loadIgnoreLists(true);

                    // Second phase of quick scanning
                    $this->queue->addMessage(State::msg('_CWIS_MESSAGE_RUNNING_QUICK_RESCAN'));

                    // Get the next portion of modified files list
                    $mod_files_list = $this->scanner->prepareRescanModifiedFiles();
                    if (!empty($mod_files_list)) {
                        $this->queue->rescan['discovered'] += count($mod_files_list);

                        // Append filenames to the exists rescan files list
                        $rescan_filepath = $this->utilities->defineFilePath('rescan');
                        if (false === file_put_contents_safe($rescan_filepath, implode("\n", $mod_files_list) . "\n",
                                FILE_APPEND | LOCK_EX)) {
                            throw new \Exception('Cannot write rescan list to file.', 500);
                        }
                    }
                    unset($mod_files_list);

                    // Check rescan offset
                    if ($this->queue->rescan['offset'] >= $this->queue->rescan['counter']) {
                        $this->queue->rescan['modified'] = 1;
                    }

                    return true;
                } else {
                    $this->queue->rescan['modified'] = 1;
                }
            }

            // Stage 3: Rescan discovered files list (after check: is rescan has been finished?)
            if ($this->queue->isFileRescanInProgress()) {

                // Include scanner methods
                $this->initScannerMethods();

                // Continue queued rescan (quick rescan)
                $this->processQueuedRescanSuspiciousFiles();
            }
        }
    }

    // High-level scan loop
    function runActiveScanLoop()
    {
        $stop_scan_loop = false;

        // Active scan loop
        while ($this->config->scan_type > 0 && !$stop_scan_loop) {

            // Locking semaphore using the file modification time
            $this->lockSharedAccessRights();

            // Run system rescan (TYPEs 1 and 2 only)
            if ($this->config->scan_type >= 1 && $this->config->scan_type <= 2) {

                // Run continuous rescan
                if ($this->continuousRescanTypeMode() && $this->config->scan_timeout <= 10) {
                    $stop_scan_loop = true; // stop on AJAX scan (timeout <= 10 sec)
                }
            }

            // Run continuous system scan (TYPEs 1, 2 and 3)
            if (!$stop_scan_loop && $this->config->scan_type >= 1 && $this->config->scan_type <= 3) {

                // Run prescan and continue on next request (if not CLI)
                if (!$this->continuousPrescan() || State::isCli()) {
                    $this->continuousScanTypeMode();
                }
            }

            // Stop on scan/rescan finish or on scan timeout
            if ($this->queue->isAllFinished()) {
                $stop_scan_loop = true;
            }

            // Create progress data object and save it
            if ($this->config->scan_type > 0) {

                // This prevents an infinite looping
                $this->config->scan_type = 1;

                // Try to save progress data (update time taken)
                $this->progress_data = $this->progress->save();

                // Silently restore progress data object on error
                if (!$this->progress_data) {
                    $this->response->jsonError('Cannot write progress data to file.');
                }
            }

            // Stop on scan timeout
            if ($this->isScanTimeout()) {
                $stop_scan_loop = true;
            }

            // Exit when connection is closed
            if (State::isCli() && connection_aborted()) {
                $stop_scan_loop = true;
            }
        }
    }

    // --- Base methods: initialise(), route() and dispatch() ---

    function initialise()
    {
        if (State::isCli()) {
            $this->logger->debugMessage('Running via the CLI');
        }

        ///////////////////////////////////////////////////////////////
        // Initialize progress method
        $this->progress->construct($this->config, $this->queue, $this->benchmark);

        // Load core file on demand
        if ($this->config->scan_type >= 1) {
            $this->initScanCoreMethods();

            // Initialize the prescan method
            $this->prescan->construct($this->config, $this->queue);
        }

        // Limit rescan features in Free version
        if ($this->config->scan_type === 2 && !$this->config->isPremium()) {
            if(CWIS_PLATFORM_TYPE != 'cpanel') {
                $this->response->jsonError('Quick Rescan is disabled in Free version.');
            }
        }

        // Create or load the config (progress) file
        $this->initProgressData($this->config);

        // Timeout correction
        $this->config->updateScanTimeout();
    }

    function route()
    {
        // Restore database state from previous scan
        if (null === $this->config->scan_database) {
            $this->config->setScanDatabase($this->queue->scan['database']);
        }

        // Restore scan level from previous scan
        if (null === $this->config->scan_level) {
            $this->config->setScanLevel($this->queue->scan['level']);
        }

        ///////////////////////////////////////////////////////////////
        // Log messages (disabled in silent mode)
        if ($this->config->scan_type > 0 && !State::cnf('api_mode')) {
            if ($this->config->scan_path !== State::scanPath()) {
                $this->logger->debugMessage('Default path: ' . State::scanPath());
            }
            $this->logger->debugMessage('Scan path: ' . $this->config->getScanPath());
            $this->logger->debugMessage('Scan depth: ' . $this->config->scan_depth . ($this->config->scan_depth >= 0 ? ' (limited)' : ' (unlimited)'));
            $this->logger->debugMessage('Scan database: ' . $this->config->scan_database . ' (' . $this->config->getScanDatabaseStr() . ')');
            $this->logger->debugMessage('Scan level: ' . $this->config->scan_level . ' (' . $this->config->getScanLevelStr() . ')');
            $this->logger->debugMessage('Scan type: ' . $this->config->scan_type . ' (' . $this->config->getScanTypeStr() . ')');
            $this->logger->debugMessage('Scan timeout: ' . $this->config->scan_timeout);

            // Write to stdout
            if (State::isCli()) {
                CwisStaticHelpers::cwis_stdout_message('=== CWIS SCANNER ' . State::version() . ' ===');
                CwisStaticHelpers::cwis_stdout_message();
                CwisStaticHelpers::cwis_stdout_message('Initialising scanner...');
                CwisStaticHelpers::cwis_stdout_message('----------------------');
                CwisStaticHelpers::cwis_stdout_message('Path to scan: ' . $this->config->scan_path);
                CwisStaticHelpers::cwis_stdout_message('Scan database: ' . $this->config->scan_database . ' (' . $this->config->getScanDatabaseStr() . ')');
                CwisStaticHelpers::cwis_stdout_message('Scan level: ' . $this->config->scan_level . ' (' . $this->config->getScanLevelStr() . ')');
                CwisStaticHelpers::cwis_stdout_message('Scan type: ' . $this->config->scan_type . ' (' . $this->config->getScanTypeStr() . ')');
                CwisStaticHelpers::cwis_stdout_message('Scan timeout: ' . $this->config->scan_timeout);
                CwisStaticHelpers::cwis_stdout_message('----------------------');
            }
        }
    }

    function dispatch()
    {
        // Timeout correction
        $this->config->updateScanTimeout();

        // Get access rights, 24 attempts every 40ms
        $this->waitForAccessRights();

        // Stop
        if ($this->config->scan_type == -1) {
            //$this->initScanCoreMethods();
            //$this->prescan->construct($this->config, $this->queue);
            // Delete prescan and progress data (eg "reload")
            //$this->prescan->delete();
            //$this->progress->delete();

            // Delete old DEBUG/QUEUE/SCANLOG files
            //$this->removeDebugScanlogFiles();
            //$this->removeQueueVolumesFiles();
           
            //$this->progress_data = $this->progress->load(true);
        }

        // Active scan loop
        if ($this->config->scan_type > 0) {
            $this->runActiveScanLoop();
        }

        // Release memory
        $this->prescan = null;
        $this->scanner = null;

        // Active scan modes
        if ($this->config->scan_type > 0) {

            // Will continue scanning on next request
            if (!$this->queue->isScanFinished()) {
                $this->logger->debugMemoryUsage('--- Scan:Continue ---');
            } else {
                // Check if server scanning is finished
                if ($this->queue->isRescanFinished()) {
                    $this->queue->setProgress(); // clear the progress path
                    $this->queue->addMessage(State::msg('_CWIS_MESSAGE_SCANNING_IS_FINISHED'));
                }
            }

            // Create progress data object and save it (don't update time taken)
            $this->progress_data = $this->progress->save(false);

            // Unlocking semaphore by file deleting
            $this->unlockSharedAccessRights();
        }
        // Non-scan cache mode (type 0)
        elseif (!State::cnf('api_mode')) {

            // Log memory usage if not in api_mode
            $this->logger->debugMemoryUsage('--- Scan:Cache ---');
        }
    }

    function finalise()
    {
      // If active scan mode and SYSTEM SCAN has been completely finished
      if ($this->config->scan_type > 0 && $this->queue->isAllFinished()) {

          // Build and send a HTML scan report (premium support)
          if (State::cnf('license') === 'Professional' ||
              State::cnf('license') === 'Premium' ||
              State::cnf('license') === 'Business') { //Business is deprecated

              $emails = [];
              if ($this->config->report_path) {
                $emails = $this->utilities->getEmails($this->config->report_path);
              }

              if ($emails) {
                  CwisApi::send_report((array) $this->progress_data, $emails);
              }
          }

      }
    }

}
