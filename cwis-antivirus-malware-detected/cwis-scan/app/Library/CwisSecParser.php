<?php

namespace App\Library;

class CwisSecParser
{

    // List of file inclusions
    var $file_inclusions = array();
    // List of function calls
    var $function_calls = array();
    // List of variable assigns
    var $variable_assigns = array();
    // Supported PHP-functions and their result token types
    var $supported_functions = array(
        'addslashes'				 => T_CONSTANT_ENCAPSED_STRING,
        'base64_decode'				 => T_CONSTANT_ENCAPSED_STRING,
        'bin2hex'					 => T_CONSTANT_ENCAPSED_STRING,
        'chop'						 => T_CONSTANT_ENCAPSED_STRING,
        'chr'						 => T_CONSTANT_ENCAPSED_STRING,
        'crc32'						 => T_LNUMBER,
        'crypt'						 => T_CONSTANT_ENCAPSED_STRING,
        'gzdecode'					 => T_CONSTANT_ENCAPSED_STRING,
        'gzinflate'					 => T_CONSTANT_ENCAPSED_STRING,
        'hebrev'					 => T_CONSTANT_ENCAPSED_STRING,
        'hebrevc'					 => T_CONSTANT_ENCAPSED_STRING,
        'hex2bin'					 => T_CONSTANT_ENCAPSED_STRING,
        'html_entity_decode'		 => T_CONSTANT_ENCAPSED_STRING,
        'htmlentities'				 => T_CONSTANT_ENCAPSED_STRING,
        'htmlspecialchars_decode'	 => T_CONSTANT_ENCAPSED_STRING,
        'htmlspecialchars'			 => T_CONSTANT_ENCAPSED_STRING,
        'lcfirst'					 => T_CONSTANT_ENCAPSED_STRING,
        'ltrim'						 => T_CONSTANT_ENCAPSED_STRING,
        'md5'						 => T_CONSTANT_ENCAPSED_STRING,
        'metaphone'					 => T_CONSTANT_ENCAPSED_STRING,
        'nl_langinfo'				 => T_CONSTANT_ENCAPSED_STRING,
        'nl2br'						 => T_CONSTANT_ENCAPSED_STRING,
        'ord'						 => T_LNUMBER,
        'quoted_printable_decode'	 => T_CONSTANT_ENCAPSED_STRING,
        'quoted_printable_encode'	 => T_CONSTANT_ENCAPSED_STRING,
        'quotemeta'					 => T_CONSTANT_ENCAPSED_STRING,
        'rawurldecode'				 => T_CONSTANT_ENCAPSED_STRING,
        'rawurlencode'				 => T_CONSTANT_ENCAPSED_STRING,
        'rtrim'						 => T_CONSTANT_ENCAPSED_STRING,
        'sha1'						 => T_CONSTANT_ENCAPSED_STRING,
        'soundex'					 => T_CONSTANT_ENCAPSED_STRING,
        'str_rot13'					 => T_CONSTANT_ENCAPSED_STRING,
        'str_shuffle'				 => T_CONSTANT_ENCAPSED_STRING,
        'strip_tags'				 => T_CONSTANT_ENCAPSED_STRING,
        'stripcslashes'				 => T_CONSTANT_ENCAPSED_STRING,
        'stripslashes'				 => T_CONSTANT_ENCAPSED_STRING,
        'strlen'					 => T_LNUMBER,
        'strtok'					 => T_CONSTANT_ENCAPSED_STRING,
        'strtolower'				 => T_CONSTANT_ENCAPSED_STRING,
        'strtoupper'				 => T_CONSTANT_ENCAPSED_STRING,
        'strrev'					 => T_CONSTANT_ENCAPSED_STRING,
        'time'						 => T_LNUMBER,
        'trim'						 => T_CONSTANT_ENCAPSED_STRING,
        'ucfirst'					 => T_CONSTANT_ENCAPSED_STRING,
        'ucwords'					 => T_CONSTANT_ENCAPSED_STRING,
        'urldecode'					 => T_CONSTANT_ENCAPSED_STRING,
        'urlencode'					 => T_CONSTANT_ENCAPSED_STRING,
        'wordwrap'					 => T_CONSTANT_ENCAPSED_STRING,
        'zlib_decode'				 => T_CONSTANT_ENCAPSED_STRING,
    );
    // Current file name
    var $file_name = '';
    // An array of tokens, generated by token_get_all()
    var $tokens = array();

    function set_file_name($file_name = '')
    {
        $this->file_name = $file_name;
    }

    function set_tokens($tokens = array())
    {
        $this->tokens = $tokens;
    }

    function get_tokens($filter = false)
    {
        return $filter ? array_values(array_filter($this->tokens)) : $this->tokens;
    }

    // Calculates expressions.
    function evaluate_expressions()
    {
        foreach ($this->tokens as $token_pos => $token) {
            // Search for string tokens
            if (is_array($token)) {
                continue;
            }

            switch ($token) {
                case '+':
                case '-':
                    // Check nearby tokens
                    $prev_token_pos = $this->prev_token_pos($token_pos);
                    $next_token_pos = $this->next_token_pos($token_pos);
                    if ($this->get_token_type($prev_token_pos) === T_LNUMBER &&
                        $this->get_token_type($next_token_pos) === T_LNUMBER) {
                        // Calculate and place result into next token
                        switch ($token) {
                            case '+':
                                $this->tokens[$next_token_pos][1] =
                                    @($this->tokens[$prev_token_pos][1] +
                                        $this->tokens[$next_token_pos][1]);
                                break;

                            case '-':
                                $this->tokens[$next_token_pos][1] =
                                    @($this->tokens[$prev_token_pos][1] -
                                        $this->tokens[$next_token_pos][1]);
                                break;
                        }

                        // Clear processed tokens
                        for ($pos = $prev_token_pos; $pos < $next_token_pos; $pos++) {
                            $this->tokens[$pos] = '';
                        }
                    }
                    break;
            }
        }
    }

    // Evaluates functions.
    function evaluate_functions()
    {
        foreach ($this->tokens as $token_pos => $token) {
            // Search for closing parenthesis
            if (is_array($token) || $token !== ')') {
                continue;
            }

            // Check if the token is surrounded by parenthesis
            $func_argument_pos = $this->prev_token_pos($token_pos);
            if ('(' === $this->get_token($func_argument_pos)) {
                $opening_parenthesis_pos = $func_argument_pos;
                $func_argument_pos = null; // no argument passed
            } else {
                $opening_parenthesis_pos = $this->prev_token_pos($func_argument_pos);
                if ('(' !== $this->get_token($opening_parenthesis_pos)) {
                    continue; // no opening parenthesis found
                }
            }

            // Define function name and check if supported
            $func_call_pos = $this->prev_token_pos($opening_parenthesis_pos);
            $func_name = $this->get_token_content($func_call_pos);
            if (isset($this->supported_functions[$func_name]) && function_exists($func_name)) {

                // Cast function argument to a string
                if (null !== $func_argument_pos) {
                    $func_argument_token_type = $this->get_token_type($func_argument_pos);
                    $func_argument = $this->tokens[$func_argument_pos][1];
                    if ($func_argument_token_type === T_CONSTANT_ENCAPSED_STRING) {
                        $func_argument = substr($func_argument, 1, -1);
                    }

                    if($func_name == 'chr') {
                      $func_argument = intval($func_argument);
                    }

                    // Evaluate function with a parameter
                    $func_result = @$func_name($func_argument);
                } else {
                    // Evaluate with no parameters (void)
                    $func_result = @$func_name();
                }

                // Cast function result, support for NULL
                $func_result_token_type = $this->supported_functions[$func_name];
                if ($func_result_token_type === T_CONSTANT_ENCAPSED_STRING) {
                    $func_result = '"' . $func_result . '"';
                } elseif (null === $func_result) {
                    $func_result = 'NULL';
                }

                // Line number (PHP 5 >= 5.2.2)
                $line_number = isset($this->tokens[$func_call_pos][2]) ? $this->tokens[$func_call_pos][2] : 0;

                // Place result into a single token
                $this->tokens[$token_pos] = array(
                    $func_result_token_type,
                    $func_result,
                    $line_number
                );

                // Clear processed tokens
                for ($pos = $func_call_pos; $pos < $token_pos; $pos++) {
                    $this->tokens[$pos] = '';
                }
            } elseif ('.' === $func_name || '(' === $func_name || ',' === $func_name ||
                '=' === $func_name || '?' === $func_name || ':' === $func_name) {
                // Strip parenthesized expressions
                $this->tokens[$opening_parenthesis_pos] = '';
                $this->tokens[$token_pos] = '';
            }
        }
    }

    // Parses string (and var values) concatenations.
    function parse_concatenations($var_declares_global = array(), $tokenid = 0)
    {
        $analyser = new CwisSecAnalyzer();
        foreach ($this->tokens as $token_pos => $token) {
            // Search for concatenation token "."
            if (is_array($token) || $token !== '.') {
                continue;
            }

            // Check left argument
            $prev_token_pos = $this->prev_token_pos($token_pos);
            $prev_token = $this->tokens[$prev_token_pos];
            if (!is_array($prev_token) || ($prev_token_type = $prev_token[0]) === T_STRING) {
                if (!isset($prev_token[1])) {
                    continue;
                }

                // Convert PHP-constants
                if ($prev_token[1] === 'DIRECTORY_SEPARATOR') {
                    $prev_token[1] = '/';
                } elseif ($prev_token[1] === 'PATH_SEPARATOR') {
                    $prev_token[1] = ';';
                } else {
                    continue; // invalid argument
                }
            } elseif ($prev_token_type === T_VARIABLE) {
                if ('' === ($var_value = $analyser->get_var_value($this->file_name, $prev_token, $var_declares_global,
                        $var_declares_global, $tokenid))) {
                    continue; // invalid value
                }

                // Convert var value
                $prev_token[1] = $var_value;
                $prev_token_type = T_STRING;
            }

            // Check right argument
            $next_token_pos = $this->next_token_pos($token_pos);
            $next_token = $this->tokens[$next_token_pos];
            if (!is_array($next_token) || ($next_token_type = $next_token[0]) === T_STRING ||
                $next_token_type === T_VARIABLE) {
                continue; // invalid argument
            }

            // Cast left argument to a string
            $left_argument = $prev_token[1];
            if ($prev_token_type === T_CONSTANT_ENCAPSED_STRING) {
                $left_argument = substr($left_argument, 1, -1);
            }

            // Cast right argument to a string
            $right_argument = $next_token[1];
            if ($next_token_type === T_CONSTANT_ENCAPSED_STRING) {
                $right_argument = substr($right_argument, 1, -1);
            }

            // Concatenate into a single token
            $concat_result = '"' . $left_argument . $right_argument . '"';

            // Line number (PHP 5 >= 5.2.2)
            $line_number = isset($prev_token[2]) ? $prev_token[2] : 0;

            // Place result into a single token
            $this->tokens[$next_token_pos] = array(
                T_CONSTANT_ENCAPSED_STRING,
                $concat_result,
                $line_number
            );

            // Clear processed tokens
            for ($pos = $prev_token_pos; $pos < $next_token_pos; $pos++) {
                $this->tokens[$pos] = '';
            }
        }
    }

    // Indexes inclusions statements.
    function index_file_inclusions($inclusion_pos, $inc_args_pos)
    {
        // Initial token position
        $token_pos = $inclusion_pos;

        // Init loop vars
        $next_token_is_argument = false;
        $opened_parenthesis = 0; // ()

        do {
            // Search for the statement argument
            $next_token_pos = $this->next_token_pos($token_pos);
            if (false === $next_token_pos) {
                break; // no tokens left
            }

            // Extract token type
            $next_token_type = $this->get_token_type($next_token_pos);
            switch ($next_token_type) {
                case '(':
                    // Ignore parenthesized statements
                    $opened_parenthesis++;
                    break;

                case ')':
                    $opened_parenthesis--;
                    break;

                case T_STRING:
                case T_VARIABLE:
                default:
                    // Indexing statement argument
                    $inc_args_pos = $next_token_pos;
                    $next_token_is_argument = true;
            }

            // Argument is detected and parenthesis is closed
            if ($next_token_is_argument && $opened_parenthesis <= 0) {
                break;
            }

            $token_pos = $next_token_pos;
        } while ($next_token_pos);

        // Save if var dest pos is set
        if (null !== $inc_args_pos) {
            $this->file_inclusions[$inclusion_pos] = $inc_args_pos;
        }

        return $next_token_pos;
    }

    // Indexes functions calls.
    function index_function_calls($func_call_pos, $func_args_pos)
    {
        // Init token positions and values
        $prev_token_pos = $func_call_pos;
        $prev_token = $this->get_token_content($prev_token_pos);
        $token_pos = $func_args_pos;
        $token = $this->get_token_content($token_pos);

        // Init loop vars
        $function_arguments = array();
        $next_token_is_argument = (bool) (null !== $func_call_pos);
        $opened_brackets = 0; // []
        $opened_parenthesis = 0; // ()

        do {
            // Search for the next argument
            $next_token_pos = $this->next_token_pos($token_pos);
            if (false === $next_token_pos) {
                break; // no tokens left
            }

            // Extract token value
            $next_token = $this->get_token_content($next_token_pos);
            switch ($next_token) {
                case '@':
                    // Ignore error control operator
                    break;

                case '.':
                case '=':
                case '?':
                case ':':
                    // Skip concatenations, assigments and ternary operators (?:)
                    $next_token_is_argument = false;
                    break;

                case ',':
                    $next_token_is_argument = true;
                    break;

                case '[':
                    $opened_brackets++;
                    break;

                case ']':
                    $opened_brackets--;
                    break;

                case '(':
                    // Handle parenthesized parameters, e.g. func(($param),'');
                    if ('(' !== $token && '?' !== $token && ':' !== $token) {
                        $next_token_pos = $this->index_function_calls($token_pos, $next_token_pos);
                    }
                    $opened_parenthesis++;
                    break;

                case ')':
                    $opened_parenthesis--;
                    break;

                default:
                    if (!$opened_parenthesis) {
                        // Indexing function arguments
                        if ($next_token_is_argument) {
                            $function_arguments[] = $next_token_pos;
                            $next_token_is_argument = false;
                        }
                    }
            }

            // Exit if brackets or parenthesis are closed
            if ($opened_brackets < 0 || $opened_parenthesis < 0) {
                break;
            }

            $prev_token_pos = $token_pos;
            $prev_token = $token;

            $token_pos = $next_token_pos;
            $token = $next_token;
        } while ($next_token_pos);

        // Save if prev token set
        if (null !== $func_call_pos) {
            $this->function_calls[$func_call_pos] = $function_arguments;
            return $func_args_pos + 1;
        }

        return $next_token_pos;
    }

    // Indexes functions calls.
    function index_variable_assigns($var_dest_pos, $var_source_pos)
    {
        // Initial token position
        $token_pos = $var_source_pos;

        // Init loop vars
        $next_token_is_source = false;
        $opened_parenthesis = 0; // ()

        do {
            // Search for the assigment source
            $next_token_pos = $this->next_token_pos($token_pos);
            if (false === $next_token_pos) {
                break; // no tokens left
            }

            // Extract token type
            $next_token_type = $this->get_token_type($next_token_pos);
            switch ($next_token_type) {
                case '@':
                    // Ignore error control operator
                    break;

                case '(':
                    // Ignore parenthesized expressions like $var = ('value');
                    $opened_parenthesis++;
                    break;

                case ')':
                    $opened_parenthesis--;
                    break;

                case T_STRING:
                case T_VARIABLE:
                default:
                    // Indexing function arguments
                    $var_source_pos = $next_token_pos;
                    $next_token_is_source = true;
            }

            // Source is detected and parenthesis is closed
            if ($next_token_is_source && $opened_parenthesis <= 0) {
                break;
            }

            $token_pos = $next_token_pos;
        } while ($next_token_pos);

        // Save if var dest pos is set
        if (null !== $var_dest_pos) {
            $this->variable_assigns[$var_dest_pos] = $var_source_pos;
        }

        return $next_token_pos;
    }

    // Parses variables and functions.
    // @todo Improve function processing, arguments counting etc
    function index_func_and_var_tokens()
    {
        $next_token_pos = 0;
        foreach ($this->tokens as $token_pos => $token) {
            // Skip already processed tokens
            if ($token_pos < $next_token_pos) {
                continue;
            }

            // Get token type
            $token_type = is_array($token) ? $token[0] : $token;
            switch ($token_type) {
                case '=':
                case T_AND_EQUAL:
                case T_CONCAT_EQUAL:
                case T_DIV_EQUAL:
                case T_MINUS_EQUAL:
                case T_MOD_EQUAL:
                case T_MUL_EQUAL:
                case T_OR_EQUAL:
                case T_PLUS_EQUAL:
                case T_POW_EQUAL:
                case T_SL_EQUAL:
                case T_SR_EQUAL:
                case T_XOR_EQUAL:
                    // Indexing variable assigns and assignment operators
                    $prev_token_pos = $this->prev_token_pos($token_pos);
                    $next_token_pos = $this->index_variable_assigns($prev_token_pos, $token_pos);
                    break;

                case T_INCLUDE_ONCE:
                case T_INCLUDE:
                case T_REQUIRE_ONCE:
                case T_REQUIRE:
                    // Indexing file inclusions
                    $prev_token_pos = $this->prev_token_pos($token_pos);
                    $next_token_pos = $this->index_file_inclusions($token_pos, $token_pos);
                    break;

                case '(':
                    // Indexing function calls
                    $prev_token_pos = $this->prev_token_pos($token_pos);
                    $prev_token_type = $this->get_token_type($prev_token_pos);
                    if ($prev_token_type === T_STRING || $prev_token_type === T_VARIABLE) {
                        $next_token_pos = $this->index_function_calls($prev_token_pos, $token_pos);
                    }
                    break;
            }
        }
    }

    // Removes comments from a tokenized PHP source.
    function remove_php_comments()
    {
        foreach ($this->tokens as $token_pos => $token) {
            if (is_array($token)) {
                $token_type = $token[0];
                if ($token_type === T_COMMENT || $token_type === T_DOC_COMMENT || $token_type === T_ML_COMMENT) {
                    $this->tokens[$token_pos] = '';
                }
            }
        }
    }

    // Removes whitespaces from a tokenized PHP source.
    function remove_whitespaces()
    {
        foreach ($this->tokens as $token_pos => $token) {
            if (is_array($token) && $token[0] === T_WHITESPACE) {
                $this->tokens[$token_pos] = '';
            }
        }
    }

    /**
     * Retrieve the next token position in the array of tokens.
     *
     * @param int $position The position in the token array
     * @param int $modifier The token to get (Defaults to 1, for the previous token)
     * @return false|int
     *
     * @access protected
     */
    function next_token_pos($position, $modifier = 1)
    {
        while (isset($this->tokens[$position + $modifier])) {
            $next_token = $this->tokens[$position + $modifier];

            // If the requested token is a T_WHITESPACE token, add 1 to the modifer
            if ($next_token === '' || (is_array($next_token) && $next_token[0] === T_WHITESPACE)) {
                $modifier++;
            } else {
                return $position + $modifier;
            }
        }

        // No tokens left
        return false;
    }

    /**
     * Retrieve the previous token position in the array of tokens
     *
     * @param int $position The position in the token array
     * @param int $modifier The token to get (Defaults to 1, for the previous token)
     * @return false|int
     *
     * @access protected
     */
    function prev_token_pos($position, $modifier = 1)
    {
        while (isset($this->tokens[$position - $modifier])) {
            $prev_token = $this->tokens[$position - $modifier];

            // If the requested token is a T_WHITESPACE token, add 1 to the modifer
            if ($prev_token === '' || (is_array($prev_token) && $prev_token[0] === T_WHITESPACE)) {
                $modifier++;
            } else {
                return $position - $modifier;
            }
        }

        // No tokens left
        return false;
    }

    /**
     * Retrieves the token from the array of tokens.
     *
     * @param int $position The position in the token array
     * @return mixed
     *
     * @access protected
     */
    function get_token($position)
    {
        // No tokens left?
        if (!$position || !isset($this->tokens[$position])) {
            return false;
        }

        return $this->tokens[$position];
    }

    /**
     * Retrieve the token type from the array of tokens.
     *
     * @param int $position The position in the token array
     * @return mixed
     *
     * @access protected
     */
    function get_token_type($position)
    {
        $token = $this->get_token($position);
        return is_array($token) ? $token[0] : $token;
    }

    /**
     * Retrieve the token content from the array of tokens.
     *
     * @param int $position The position in the token array
     * @return mixed
     *
     * @access protected
     */
    function get_token_content($position)
    {
        $token = $this->get_token($position);
        return is_array($token) ? $token[1] : $token;
    }

    /**
     * Retrieve the next token from the array of tokens.
     *
     * @param int $position The current position in the token array
     * @return mixed
     *
     * @access protected
     */
    function next_token($position)
    {
        $next_token_pos = $this->next_token_pos($position);
        return $this->get_token_type($next_token_pos);
    }

    /**
     * Retrieve the previous token from the array of tokens
     *
     * @param int $position The position in the token array
     * @param int $modifier The token to get (Defaults to 1, for the previous token)
     * @return int
     *
     * @access protected
     */
    function prev_token($position)
    {
        $prev_token_pos = $this->prev_token_pos($position);
        return $this->get_token_type($prev_token_pos);
    }

}
